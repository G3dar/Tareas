<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eggscape Build Notes - 2025-10-13</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: #1a1a2e;
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #00ff88;
            font-size: 1.5rem;
        }

        .header .date {
            color: #888;
            font-size: 0.9rem;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .terminal-section {
            flex: 1;
            display: none; /* Ocultado */
            flex-direction: column;
            background: #0f0f1a;
            border-right: 2px solid #1a1a2e;
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-size: 0.95rem;
        }

        .terminal-line {
            margin-bottom: 15px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            animation: fadeIn 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .terminal-line-main {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .terminal-line-text {
            flex: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .terminal-line .prompt {
            color: #00ff88;
            margin-right: 10px;
        }

        .terminal-line .text {
            color: #eee;
        }

        .terminal-line .ai-processing {
            color: #ffa500;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        .terminal-line .ai-result {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .terminal-category-badge {
            background: #16213e;
            color: #00ff88;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .terminal-tag {
            background: #0f3a2e;
            color: #00ff88;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #00ff8844;
        }

        .assignment-mode-toggle {
            background: #2e1a3a;
            color: #ff88ff;
            border: 2px solid #ff88ff44;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .assignment-mode-toggle.active {
            background: #4a2a5a;
            border-color: #ff88ff;
        }

        .assignment-mode-toggle:hover {
            background: #3a2050;
        }

        .assignment-section {
            margin-top: 8px;
            padding: 8px;
            background: #0f0f1a;
            border-radius: 4px;
            border: 1px solid #ff88ff44;
        }

        .assignment-people {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .person-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #1a1a2e;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            border: 1px solid #ff88ff44;
        }

        .person-checkbox:hover {
            background: #242444;
        }

        .person-checkbox input[type="checkbox"],
        .person-checkbox input[type="radio"] {
            cursor: pointer;
            margin: 0;
        }

        .person-checkbox.selected {
            background: #2e1a3a;
            border-color: #ff88ff;
        }

        .assigned-person {
            background: #2e1a3a;
            color: #ff88ff;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #ff88ff88;
            white-space: nowrap;
        }

        .assigned-people-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .terminal-input-container {
            background: #1a1a2e;
            padding: 20px;
            border-top: 2px solid #00ff88;
        }

        .terminal-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-input-wrapper .prompt {
            color: #00ff88;
            font-size: 1.2rem;
            font-weight: bold;
        }

        #terminalInput {
            flex: 1;
            background: #0f0f1a;
            border: 2px solid #16213e;
            color: #00ff88;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            border-radius: 4px;
        }

        #terminalInput:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        #buildReviewInput {
            flex: 1;
            background: #000000;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 18px 24px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: 500;
            border-radius: 8px;
            width: 100%;
            letter-spacing: 0.5px;
        }

        #buildReviewInput:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            background: #0a0a0a;
        }

        #buildReviewInput::placeholder {
            color: #00ff8866;
            font-style: italic;
        }

        .notes-section {
            width: 100%; /* Pantalla completa */
            background: #0f0f1a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .notes-header {
            background: #1a1a2e;
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notes-header h2 {
            color: #00ff88;
            font-size: 1.2rem;
        }

        .notes-count {
            color: #888;
            font-size: 0.9rem;
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tag-group {
            margin-bottom: 25px;
        }

        .tag-group-header {
            color: #00ff88;
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #16213e;
            display: flex;
            justify-content: space-between;
        }

        .person-group {
            margin-bottom: 30px;
        }

        .person-group-header {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 15px;
            padding: 12px;
            padding-bottom: 10px;
            border-bottom: 3px solid;
            border-radius: 4px 4px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-badge {
            background: #16213e;
            color: #00ff88;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .note-card {
            background: #1a1a2e;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            transition: all 0.2s;
        }

        .note-card:hover {
            background: #242444;
        }

        .note-card.priority-critical {
            border-left-color: #ff0040;
            background: #2a1a20;
        }

        .note-card.priority-high {
            border-left-color: #ff6600;
            background: #2a2010;
        }

        .note-card.priority-medium {
            border-left-color: #ffcc00;
            background: #2a2610;
        }

        .note-card.priority-low {
            border-left-color: #00aaff;
            background: #1a2030;
        }

        .note-card-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 8px;
        }

        .note-card-text {
            color: #eee;
            font-size: 0.9rem;
            word-break: break-word;
            flex: 1;
        }

        .note-card-text:hover {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
        }

        .note-card-badges {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
            flex-shrink: 0;
        }

        .note-category-badge {
            background: #16213e;
            color: #00ff88;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .note-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: flex-end;
            max-width: 200px;
        }

        .note-tag {
            background: #0f3a2e;
            color: #00ff88;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #00ff8844;
            white-space: nowrap;
        }

        .note-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            font-size: 0.75rem;
            color: #888;
            flex-wrap: wrap;
        }

        .priority-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .priority-badge:hover {
            transform: scale(1.1);
        }

        .priority-critical {
            background: #ff0040;
            color: white;
        }

        .priority-high {
            background: #ff6600;
            color: white;
        }

        .priority-medium {
            background: #ffcc00;
            color: #1a1a2e;
        }

        .priority-low {
            background: #00aaff;
            color: white;
        }

        .priority-selector {
            position: absolute;
            background: #1a1a2e;
            border: 2px solid #00ff88;
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .priority-selector.active {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .priority-option {
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            border: none;
            font-family: 'Courier New', monospace;
        }

        .priority-option:hover {
            transform: scale(1.05);
        }

        .work-status-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .work-status-badge:hover {
            transform: scale(1.1);
        }

        .work-status-selector {
            position: absolute;
            background: #1a1a2e;
            border: 2px solid #00ff88;
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .work-status-selector.active {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .work-status-option {
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            border: none;
            font-family: 'Courier New', monospace;
            color: white;
        }

        .work-status-option:hover {
            transform: scale(1.05);
        }

        .delete-btn, .edit-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .edit-btn {
            background: #0088ff;
        }

        .delete-btn:hover {
            background: #ff6680;
        }

        .edit-btn:hover {
            background: #00aaff;
        }

        .note-edit-input {
            width: 100%;
            background: #0f0f1a;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .note-edit-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .edit-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }

        .save-btn, .cancel-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .save-btn {
            background: #00ff88;
            color: #0a0a0f;
            font-weight: bold;
        }

        .save-btn:hover {
            background: #00ffaa;
        }

        .cancel-btn {
            background: #666;
            color: white;
        }

        .cancel-btn:hover {
            background: #888;
        }

        .history-toggle {
            background: #16213e;
            color: #00ff88;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .history-toggle:hover {
            background: #242444;
        }

        .history-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: #1a1a2e;
            border-left: 2px solid #00ff88;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .history-panel.active {
            right: 0;
        }

        .history-panel-header {
            padding: 15px 20px;
            background: #0f0f1a;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-panel-header h3 {
            color: #00ff88;
        }

        .close-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .day-filter-btn {
            padding: 6px 14px;
            background: #16213e;
            color: #888;
            border: 1px solid #00ff8844;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .day-filter-btn.active {
            background: #00ff88;
            color: #0a0a0f;
            font-weight: bold;
        }

        .day-filter-btn:hover {
            background: #1a2e3e;
        }

        .history-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .history-item {
            background: #0f0f1a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .history-item .time {
            color: #00ff88;
            margin-right: 10px;
        }

        .history-item .action {
            color: #888;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0f;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Review Mode Styles */
        .review-panel {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            background: #0a0a0f;
            z-index: 1001;
            display: none;
            flex-direction: column;
        }

        .review-panel.active {
            display: flex;
        }

        .main-container.review-active {
            display: none;
        }

        .review-header {
            padding: 15px 20px;
            background: #0f0f1a;
            border-bottom: 2px solid #ffaa00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-header h3 {
            color: #ffaa00;
        }

        .review-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .review-toggle {
            background: #3a2010;
            color: #ffaa00;
            border: 2px solid #ffaa0044;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .review-toggle.active {
            background: #5a3010;
            border-color: #ffaa00;
        }

        .review-content {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .review-person-section {
            margin-bottom: 50px;
            background: #0f0f1a;
            border-radius: 8px;
            padding: 25px;
            border: 2px solid #ffaa0044;
        }

        .review-person-title {
            color: #ffaa00;
            font-weight: bold;
            font-size: 1.8rem;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #ffaa00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-person-count {
            font-size: 1.2rem;
            color: #888;
            font-weight: normal;
        }

        .review-nav {
            background: #0f0f1a;
            padding: 15px 40px;
            border-bottom: 2px solid #ffaa0044;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .review-nav-link {
            background: #1a1a2e;
            color: #ffaa00;
            padding: 8px 16px;
            border-radius: 4px;
            border: 2px solid #ffaa0044;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.2s;
        }

        .review-nav-link:hover {
            background: #3a2010;
            border-color: #ffaa00;
            transform: translateY(-2px);
        }

        .review-nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding-left: 20px;
            margin-left: 20px;
            border-left: 2px solid #ffaa0044;
        }

        .review-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ffaa00;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
        }

        .review-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .review-item {
            background: #1a1a2e;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 6px;
            border-left: 4px solid #ffaa00;
        }

        .review-item.accepted {
            border-left-color: #00ff88;
            background: #0f1a14;
        }

        .review-item.rejected {
            border-left-color: #e94560;
            background: #1a0f14;
        }

        .review-item-text {
            color: #eee;
            font-size: 1.05rem;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .review-item-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 0.75rem;
        }

        .review-meta-badge {
            background: #16213e;
            color: #00ff88;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
        }

        .review-filter-container {
            padding: 15px 40px;
            background: #0f0f1a;
            border-bottom: 2px solid #ffaa0044;
        }

        .review-filter-input {
            width: 100%;
            background: #1a1a2e;
            border: 2px solid #ffaa0044;
            color: #ffaa00;
            padding: 12px 15px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .review-filter-input:focus {
            outline: none;
            border-color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .review-filter-input::placeholder {
            color: #888;
        }

        .review-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .review-btn-accept, .review-btn-reject {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        .review-btn-accept {
            background: #00ff88;
            color: #0a0a0f;
        }

        .review-btn-accept:hover {
            background: #00ffaa;
            transform: scale(1.05);
        }

        .review-btn-reject {
            background: #e94560;
            color: white;
        }

        .review-btn-reject:hover {
            background: #ff6680;
            transform: scale(1.05);
        }

        .review-comment-input {
            width: 100%;
            background: #0f0f1a;
            border: 2px solid #e94560;
            color: #eee;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border-radius: 4px;
            margin-top: 10px;
        }

        .review-comment-input:focus {
            outline: none;
            border-color: #ff6680;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
        }

        .review-comment-display {
            margin-top: 10px;
            padding: 8px;
            background: #1a0f14;
            border-left: 3px solid #e94560;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #ff6680;
        }

        .review-status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .review-status-accepted {
            background: #00ff88;
            color: #0a0a0f;
        }

        .review-status-rejected {
            background: #e94560;
            color: white;
        }

        @media (max-width: 1024px) {
            .notes-section {
                width: 100%; /* Pantalla completa en todas las resoluciones */
            }
        }

        @media (max-width: 768px) {
            /* Header adaptado para mobile */
            .header {
                flex-direction: column;
                gap: 10px;
                padding: 12px;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.2rem;
                text-align: center;
                margin-bottom: 8px;
            }

            .header > div {
                flex-direction: column;
                gap: 8px !important;
                width: 100%;
            }

            .header button {
                width: 100%;
                padding: 10px !important;
                font-size: 0.9rem !important;
            }

            .date {
                text-align: center;
                width: 100%;
            }

            /* Main container en columna */
            .main-container {
                flex-direction: column;
                height: auto;
            }

            .terminal-section {
                width: 100%;
                height: 50vh;
                min-height: 300px;
                border-right: none;
                display: none; /* Ocultado en mobile tambi√©n */
            }

            .terminal-input {
                font-size: 0.9rem;
                padding: 12px;
            }

            .terminal-output {
                font-size: 0.85rem;
                padding: 15px;
            }

            .notes-section {
                width: 100%;
                height: auto;
                min-height: 50vh;
                border-right: none;
                border-top: 2px solid #1a1a2e;
            }

            .notes-header {
                padding: 12px;
                flex-wrap: wrap;
                gap: 8px;
            }

            .notes-header button {
                font-size: 0.8rem;
                padding: 6px 10px;
            }

            /* Historial mobile */
            .history-panel {
                width: 100%;
                left: 0;
            }

            /* Review mode mobile */
            .review-panel {
                padding: 0;
            }

            .review-header {
                flex-direction: column;
                gap: 10px;
                padding: 12px;
            }

            .review-controls {
                width: 100%;
                flex-direction: column;
                gap: 8px;
            }

            .review-controls button {
                width: 100%;
            }

            .review-filter-container {
                padding: 12px;
            }

            .review-filter-input {
                font-size: 0.9rem;
            }

            #reviewPersonFilters {
                gap: 6px !important;
            }

            #reviewPersonFilters button {
                font-size: 0.75rem !important;
                padding: 6px 8px !important;
            }

            .review-content {
                padding: 12px;
            }

            .review-item {
                padding: 12px;
                font-size: 0.9rem;
            }

            .review-item-meta {
                flex-wrap: wrap;
                gap: 6px;
            }

            .review-meta-badge {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            /* Assignment mode mobile */
            .assignment-section {
                padding: 10px;
            }

            .assignment-people {
                gap: 6px;
            }

            .person-checkbox {
                font-size: 0.75rem;
                padding: 6px 10px;
            }

            .assigned-person {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            /* Note cards mobile */
            .note-card {
                padding: 12px;
                font-size: 0.9rem;
            }

            .note-card-text {
                font-size: 0.9rem;
                line-height: 1.4;
            }

            .note-category-badge,
            .note-tag {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            .note-card-meta {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }

            .note-card-meta > div {
                width: 100%;
                justify-content: flex-start;
            }

            .priority-badge,
            .work-status-badge {
                font-size: 0.75rem;
                padding: 4px 10px;
            }

            .edit-btn,
            .delete-btn,
            .save-btn,
            .cancel-btn {
                font-size: 0.8rem;
                padding: 6px 10px;
            }

            /* Tag groups mobile */
            .tag-group-header {
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            /* Terminal line mobile */
            .terminal-line {
                font-size: 0.85rem;
            }

            .terminal-category-badge,
            .terminal-tag {
                font-size: 0.7rem;
                padding: 3px 6px;
            }

            /* Work status selector mobile */
            .work-status-selector,
            .priority-selector {
                width: 100%;
                left: 0 !important;
                right: 0 !important;
            }

            .work-status-option,
            .priority-option {
                font-size: 0.8rem;
                padding: 10px;
            }

            /* Review person section mobile */
            .review-person-section {
                margin-bottom: 20px;
            }

            .review-person-title {
                font-size: 1rem;
                padding: 10px;
            }

            /* Hide some elements on very small screens */
            .date {
                font-size: 0.85rem;
            }
        }

        /* Landscape mobile adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .terminal-section {
                height: 40vh;
                display: none; /* Ocultado en landscape tambi√©n */
            }

            .notes-section {
                min-height: 100vh; /* Pantalla completa en landscape */
            }
        }

        /* Very small mobile devices */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1rem;
            }

            .terminal-output {
                font-size: 0.8rem;
                padding: 10px;
            }

            .terminal-input {
                font-size: 0.85rem;
                padding: 10px;
            }

            .note-card {
                padding: 10px;
            }

            .review-item {
                padding: 10px;
            }

            #reviewPersonFilters {
                font-size: 0.7rem;
            }

            #reviewPersonFilters button {
                font-size: 0.7rem !important;
                padding: 5px 6px !important;
            }

            .assignment-people label {
                font-size: 0.7rem;
                padding: 5px 8px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div class="header">
        <h1>ü•ö Eggscape Build Notes</h1>
        <div style="display: flex; gap: 15px; align-items: center;">
            <div class="date">2025-10-13</div>
            <button class="assignment-mode-toggle" id="buildReviewModeBtn" onclick="toggleBuildReviewMode()" style="background: #1a3a2e; color: #00ff88; border-color: #00ff8844;">
                üìù BUILD REVIEW
            </button>
            <button class="assignment-mode-toggle" id="assignmentModeBtn" onclick="toggleAssignmentMode()">
                üë• MODO ASIGNACI√ìN
            </button>
            <button class="assignment-mode-toggle" id="reviewModeBtn" onclick="toggleReviewMode()" style="background: #3a2010; color: #ffaa00; border-color: #ffaa0044;">
                ‚úì MODO REVISI√ìN
            </button>
            <button class="history-toggle" onclick="exportNotes()" style="padding: 6px 12px; font-size: 0.85rem;">üì• Exportar</button>
            <button class="history-toggle" onclick="exportByPerson()" style="padding: 6px 12px; font-size: 0.85rem;">üë• Exportar por Persona</button>
            <button class="history-toggle" onclick="document.getElementById('importFile').click()" style="padding: 6px 12px; font-size: 0.85rem;">üì§ Importar</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importNotes(event)">
            <button class="history-toggle" onclick="toggleHistory()">üìú Historial</button>
        </div>
    </div>

    <div class="main-container">
        <div class="terminal-section">
            <div id="assignmentFilterBar" style="display: none; padding: 10px 15px; background: #0f0f1a; border-bottom: 1px solid #1a1a2e;">
                <input
                    type="text"
                    id="assignmentFilterInput"
                    placeholder="üîç Filtrar por palabra clave..."
                    oninput="filterAssignmentNotes()"
                    style="width: 100%; padding: 8px 12px; background: #16213e; border: 1px solid #00ff8844; border-radius: 4px; color: #eee; font-size: 0.9rem; margin-bottom: 10px;"
                >
                <div id="assignmentPersonFilters" style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <!-- Los filtros se generar√°n din√°micamente aqu√≠ -->
                </div>
            </div>
            <div class="terminal-output" id="terminalOutput">
                <div style="color: #00ff88; margin-bottom: 20px; font-size: 1.1rem;">
                    üí¨ Escribe tus notas y presiona Enter. La AI las organizar√° autom√°ticamente.
                </div>
            </div>
            <div class="terminal-input-container">
                <div class="terminal-input-wrapper">
                    <span class="prompt">></span>
                    <input
                        type="text"
                        id="terminalInput"
                        placeholder="Escribe aqu√≠ tu nota..."
                        autofocus
                    >
                </div>
            </div>
        </div>

        <div class="notes-section">
            <div class="notes-header">
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <h2>üìã Notas Organizadas</h2>
                    <span class="notes-count" id="notesCount">0 notas</span>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                    <div style="display: flex; gap: 5px; background: #16213e; padding: 4px; border-radius: 4px;">
                        <button class="view-toggle-btn active" id="viewByCategoryBtn" onclick="toggleView('category')" style="padding: 6px 12px; font-size: 0.8rem; border: none; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace; transition: all 0.2s; background: #00ff88; color: #0a0a0f; font-weight: bold;">
                            üìÇ Por Categor√≠a
                        </button>
                        <button class="view-toggle-btn" id="viewByPersonBtn" onclick="toggleView('person')" style="padding: 6px 12px; font-size: 0.8rem; border: none; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace; transition: all 0.2s; background: transparent; color: #888;">
                            üë• Por Persona
                        </button>
                    </div>
                    <button class="history-toggle" onclick="recategorizeAndGroup()" style="padding: 6px 12px; font-size: 0.8rem;">üîÑ Recategorizar y Agrupar</button>
                    <button class="delete-btn" onclick="clearAllNotes()" style="padding: 8px 16px;">üóëÔ∏è Borrar Todo</button>
                </div>
            </div>
            <div class="notes-list" id="notesList">
                <div class="empty-state">No hay notas a√∫n.<br>Empieza a escribir!</div>
            </div>
        </div>
    </div>

    <div class="history-panel" id="historyPanel">
        <div class="history-panel-header">
            <h3>üìú Historial Completo</h3>
            <button class="close-btn" onclick="toggleHistory()">Cerrar</button>
        </div>
        <div class="history-content" id="historyContent">
            <div class="empty-state">No hay historial a√∫n</div>
        </div>
    </div>

    <!-- Panel de BUILD REVIEW -->
    <div class="review-panel" id="buildReviewPanel">
        <div class="review-header">
            <h3>üìù Build Review</h3>
            <div class="review-controls">
                <button class="close-btn" onclick="toggleBuildReviewMode()">Cerrar</button>
            </div>
        </div>
        <div class="review-filter-container">
            <!-- Filtros de d√≠as de la semana -->
            <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
                <span style="color: #888; font-size: 0.85rem; margin-right: 5px;">D√≠a:</span>
                <button onclick="filterBuildReviewByDay('mon')" id="dayBtn-mon" class="day-filter-btn">LUN</button>
                <button onclick="filterBuildReviewByDay('tue')" id="dayBtn-tue" class="day-filter-btn">MAR</button>
                <button onclick="filterBuildReviewByDay('wed')" id="dayBtn-wed" class="day-filter-btn">MIE</button>
                <button onclick="filterBuildReviewByDay('thu')" id="dayBtn-thu" class="day-filter-btn">JUE</button>
                <button onclick="filterBuildReviewByDay('fri')" id="dayBtn-fri" class="day-filter-btn">VIE</button>
                <button onclick="filterBuildReviewByDay('sat')" id="dayBtn-sat" class="day-filter-btn">SAB</button>
                <button onclick="filterBuildReviewByDay('sun')" id="dayBtn-sun" class="day-filter-btn">DOM</button>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <button onclick="filterBuildReviewByDay('all')" id="dayBtn-all" class="day-filter-btn" style="font-weight: bold;">TODOS</button>
            </div>
            <!-- Checkbox ocultar aceptados -->
            <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                <input
                    type="checkbox"
                    id="buildReviewHideAcceptedCheckbox"
                    onchange="toggleBuildReviewHideAccepted()"
                    style="cursor: pointer;"
                >
                Ocultar aceptados
            </label>
        </div>
        <!-- Input para nuevas notas -->
        <div class="terminal-input-container" style="margin: 15px 20px;">
            <div class="terminal-input-wrapper">
                <span class="prompt">></span>
                <input
                    type="text"
                    id="buildReviewInput"
                    placeholder="Escribe aqu√≠ tu nota..."
                >
            </div>
        </div>
        <div class="review-content" id="buildReviewContent">
            <div class="empty-state">No hay notas para esta semana</div>
        </div>
    </div>

    <div class="review-panel" id="reviewPanel">
        <div class="review-header">
            <h3>‚úì Modo Revisi√≥n</h3>
            <div class="review-controls">
                <button class="review-toggle" id="reviewGroupToggle" onclick="toggleReviewGrouping()">
                    Por Persona
                </button>
                <button class="close-btn" onclick="toggleReviewMode()">Cerrar</button>
            </div>
        </div>
        <div class="review-filter-container">
            <input
                type="text"
                id="reviewFilterInput"
                class="review-filter-input"
                placeholder="üîç Filtrar por palabra clave..."
                oninput="filterReviewNotes()"
            >
            <div id="reviewPersonFilters" style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px;">
                <!-- Los filtros se generar√°n din√°micamente aqu√≠ -->
            </div>
        </div>
        <div class="review-content" id="reviewContent">
            <div class="empty-state">No hay notas para revisar</div>
        </div>
    </div>

    <script>
        // Inicializar Supabase
        const SUPABASE_URL = 'https://rhzfstnkavzqvcymavua.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJoemZzdG5rYXZ6cXZjeW1hdnVhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyMTQxMjgsImV4cCI6MjA3NTc5MDEyOH0.K6QTSU7uTvxPUIqSLS5_TI6bzmqV1hYswOpHyjLZcio';

        console.log('üîß [INIT] Inicializando Supabase client...');
        console.log('üîß [INIT] window.supabase disponible:', !!window.supabase);

        if (!window.supabase) {
            console.error('‚ùå [INIT] window.supabase NO est√° disponible! El CDN no carg√≥ correctamente.');
            alert('ERROR: Supabase library no carg√≥. Revisa la consola.');
        }

        const { createClient } = window.supabase;
        console.log('üîß [INIT] createClient function:', typeof createClient);

        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ [INIT] Supabase client creado exitosamente');
        console.log('üîß [INIT] Supabase URL:', SUPABASE_URL);
        console.log('üîß [INIT] Key prefix:', SUPABASE_ANON_KEY.substring(0, 20) + '...');

        // Estado de la aplicaci√≥n
        let notes = [];
        let history = [];
        let buildReviewMode = false; // Modo BUILD REVIEW
        let buildReviewSelectedDay = 'all'; // 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'all'
        let buildReviewHideAccepted = false; // Ocultar tareas aceptadas en build review
        let assignmentMode = false;
        let assignmentViewMode = 'category'; // 'category' o 'person'
        let assignmentHideAccepted = false; // Ocultar tareas aceptadas en modo asignaci√≥n
        let assignmentFilterText = ''; // Texto del filtro de asignaci√≥n
        let assignmentFilterPerson = null; // Filtro por persona en modo asignaci√≥n (null = todas)
        let collapsedAssignments = new Set(); // IDs de notas con asignaciones colapsadas
        let editingAssignments = new Set(); // IDs de notas en modo de edici√≥n de asignaci√≥n
        let reviewMode = false;
        let reviewGroupByPerson = true; // true = por persona, false = por categor√≠a/tags
        let reviewFilterText = ''; // Texto del filtro de revisi√≥n
        let reviewFilterPerson = null; // Filtro por persona (null = todas)
        let reviewHideAccepted = false; // Ocultar tareas aceptadas

        // Lista de personas para asignar
        const people = ['VALEN', 'PABLO', 'MATI', 'LUKAKU', 'LUCASM', 'FEDEM', 'AGUS'];

        // Colores para cada persona
        const personColors = {
            'VALEN': '#ff6b9d',
            'PABLO': '#4ecdc4',
            'MATI': '#ffd93d',
            'LUKAKU': '#95e1d3',
            'LUCASM': '#c77dff',
            'FEDEM': '#ff9a56',
            'AGUS': '#70e000'
        };

        // Opciones de dificultad
        const difficulties = ['EASY', 'MEDIUM', 'HARD'];

        // Opciones de prioridad
        const priorities = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];

        // Estados de trabajo
        const workStatuses = ['not_started', 'wip', 'awaiting_review', 'accepted', 'rejected'];
        const workStatusLabels = {
            'not_started': '‚≠ï NO EMPEZADO',
            'wip': 'üîÑ WIP',
            'awaiting_review': '‚è≥ ESPERANDO REVISI√ìN',
            'accepted': '‚úÖ ACEPTADO',
            'rejected': '‚ùå RECHAZADO'
        };
        const workStatusColors = {
            'not_started': '#666',
            'wip': '#0088ff',
            'awaiting_review': '#ffaa00',
            'accepted': '#00ff88',
            'rejected': '#e94560'
        };

        // Tags conocidos del juego Eggscape
        const knownTags = [
            'PIECES', 'ENEMIGOS', 'FUNCTIONALITY', 'MODO EDIT', 'PAUSA', 'LAYERS', 'UI',
            'PACKS', 'SHD', 'OTHER', 'COLLECTABLES', 'COLLIDER', 'POLLERA', 'LOOK',
            'MENU WB', 'ROY', 'SOUND', 'HONOR', 'RANK', 'GREEDY PIGGY', 'LEVELS',
            'GRID', 'BACKEND', 'PLAY', 'FRENZY', 'WEAPONS', 'MARKET', 'GRABBABLES',
            'MATCHMAKING', 'VR MODE', 'SNAPPING', 'LOBBY', 'FRIENDING', 'AUTOSAVE',
            'VEHICLES', 'TUTORIAL', 'COMBAT', 'VOICECHAT', 'PERFORMANCE', 'TOOLS',
            'COSMETICS', 'BUILDER', 'POWERUPS', 'LOGS', 'CAMERA', 'RACE MODE'
        ];

        // ===== REVIEW MODE FUNCTIONS =====

        // Toggle modo revisi√≥n
        function toggleReviewMode() {
            reviewMode = !reviewMode;
            const btn = document.getElementById('reviewModeBtn');
            const panel = document.getElementById('reviewPanel');
            const mainContainer = document.querySelector('.main-container');

            if (reviewMode) {
                btn.classList.add('active');
                panel.classList.add('active');
                mainContainer.classList.add('review-active');
                renderPersonFilters();
                renderReviewMode();
            } else {
                btn.classList.remove('active');
                panel.classList.remove('active');
                mainContainer.classList.remove('review-active');
            }
        }

        // Renderizar filtros de personas
        function renderPersonFilters() {
            const container = document.getElementById('reviewPersonFilters');
            if (!container) return;

            let html = `
                <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                    <input
                        type="checkbox"
                        id="hideAcceptedCheckbox"
                        onchange="toggleHideAccepted()"
                        style="cursor: pointer;"
                        ${reviewHideAccepted ? 'checked' : ''}
                    >
                    Ocultar aceptados
                </label>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <span style="color: #888; font-size: 0.85rem;">Filtrar por persona:</span>
                <button
                    onclick="filterByPerson(null)"
                    style="padding: 4px 10px; background: ${reviewFilterPerson === null ? '#00ff88' : '#16213e'}; color: ${reviewFilterPerson === null ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${reviewFilterPerson === null ? 'bold' : 'normal'};"
                >
                    Todas
                </button>
            `;

            people.forEach(person => {
                html += `
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <button
                            onclick="filterByPerson('${person}')"
                            style="padding: 4px 10px; background: ${reviewFilterPerson === person ? '#00ff88' : '#16213e'}; color: ${reviewFilterPerson === person ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${reviewFilterPerson === person ? 'bold' : 'normal'};"
                        >
                            ${person}
                        </button>
                        <button
                            onclick="copyPersonLink('${person}', event)"
                            style="padding: 4px 8px; background: #16213e; color: #00ff88; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem;"
                            title="Copiar link personal de ${person}"
                        >
                            üìã
                        </button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filtrar por persona
        function filterByPerson(person) {
            reviewFilterPerson = person;
            renderPersonFilters();
            renderReviewMode();
        }

        // Copiar link personal
        function copyPersonLink(person, event) {
            const personLower = person.toLowerCase();
            const baseUrl = window.location.origin + window.location.pathname;
            const personalUrl = `${baseUrl}?person=${personLower}`;

            // Intentar copiar al portapapeles
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(personalUrl).then(() => {
                    // Mostrar notificaci√≥n de √©xito
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = '‚úì';
                    button.style.background = '#00ff88';
                    button.style.color = '#0a0a0f';

                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#16213e';
                        button.style.color = '#00ff88';
                    }, 1500);
                }).catch(err => {
                    console.error('Error copiando link:', err);
                    // Fallback: mostrar el link en un prompt
                    prompt('Copia este link:', personalUrl);
                });
            } else {
                // Fallback si no hay soporte para clipboard API
                prompt('Copia este link:', personalUrl);
            }
        }

        // Renderizar filtros de personas para modo asignaci√≥n
        function renderAssignmentFilters() {
            const container = document.getElementById('assignmentPersonFilters');
            if (!container) return;

            let html = `
                <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                    <input
                        type="checkbox"
                        id="assignmentHideAcceptedCheckbox"
                        onchange="toggleAssignmentHideAccepted()"
                        style="cursor: pointer;"
                        ${assignmentHideAccepted ? 'checked' : ''}
                    >
                    Ocultar aceptados
                </label>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <span style="color: #888; font-size: 0.85rem;">Filtrar por persona:</span>
                <button
                    onclick="filterAssignmentByPerson(null)"
                    style="padding: 4px 10px; background: ${assignmentFilterPerson === null ? '#00ff88' : '#16213e'}; color: ${assignmentFilterPerson === null ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${assignmentFilterPerson === null ? 'bold' : 'normal'};"
                >
                    Todas
                </button>
            `;

            people.forEach(person => {
                html += `
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <button
                            onclick="filterAssignmentByPerson('${person}')"
                            style="padding: 4px 10px; background: ${assignmentFilterPerson === person ? '#00ff88' : '#16213e'}; color: ${assignmentFilterPerson === person ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${assignmentFilterPerson === person ? 'bold' : 'normal'};"
                        >
                            ${person}
                        </button>
                        <button
                            onclick="copyPersonLink('${person}', event)"
                            style="padding: 4px 8px; background: #16213e; color: #00ff88; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem;"
                            title="Copiar link personal de ${person}"
                        >
                            üìã
                        </button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filtrar por persona en modo asignaci√≥n
        function filterAssignmentByPerson(person) {
            assignmentFilterPerson = person;
            renderAssignmentFilters();
            renderNotes();
        }

        // Filtrar por texto en modo asignaci√≥n
        function filterAssignmentNotes() {
            const input = document.getElementById('assignmentFilterInput');
            assignmentFilterText = input.value.toLowerCase();
            renderNotes();
        }

        // Toggle ocultar aceptados
        function toggleHideAccepted() {
            const checkbox = document.getElementById('hideAcceptedCheckbox');
            reviewHideAccepted = checkbox.checked;
            renderReviewMode();
        }

        // Toggle agrupamiento (persona vs categor√≠a)
        function toggleReviewGrouping() {
            reviewGroupByPerson = !reviewGroupByPerson;
            const btn = document.getElementById('reviewGroupToggle');
            btn.textContent = reviewGroupByPerson ? 'Por Persona' : 'Por Categor√≠a';
            renderReviewMode();
        }

        // Filtrar notas en review mode
        function filterReviewNotes() {
            const input = document.getElementById('reviewFilterInput');
            reviewFilterText = input.value.toLowerCase().trim();
            renderReviewMode();
        }

        // ===== BUILD REVIEW FUNCTIONS =====

        // Toggle modo BUILD REVIEW
        function toggleBuildReviewMode() {
            buildReviewMode = !buildReviewMode;
            const btn = document.getElementById('buildReviewModeBtn');
            const panel = document.getElementById('buildReviewPanel');
            const mainContainer = document.querySelector('.main-container');

            if (buildReviewMode) {
                btn.classList.add('active');
                panel.classList.add('active');
                mainContainer.classList.add('review-active');

                // Marcar el bot√≥n del d√≠a actual como activo si ninguno est√° activo
                const activeDayBtn = document.querySelector('.day-filter-btn.active');
                if (!activeDayBtn) {
                    // Marcar "TODOS" por defecto
                    const allBtn = document.getElementById('dayBtn-all');
                    if (allBtn) allBtn.classList.add('active');
                }

                renderBuildReview();
            } else {
                btn.classList.remove('active');
                panel.classList.remove('active');
                mainContainer.classList.remove('review-active');
            }
        }

        // Filtrar BUILD REVIEW por d√≠a
        function filterBuildReviewByDay(day) {
            buildReviewSelectedDay = day;

            // Actualizar estilos de botones
            const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'all'];
            days.forEach(d => {
                const btn = document.getElementById(`dayBtn-${d}`);
                if (btn) {
                    if (d === day) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });

            renderBuildReview();
        }

        // Toggle ocultar aceptados en BUILD REVIEW
        function toggleBuildReviewHideAccepted() {
            const checkbox = document.getElementById('buildReviewHideAcceptedCheckbox');
            buildReviewHideAccepted = checkbox.checked;
            renderBuildReview();
        }

        // Obtener d√≠a de la semana de una fecha (0=Domingo, 1=Lunes, ...)
        function getDayOfWeek(dateString) {
            const date = new Date(dateString);
            return date.getDay(); // 0=Domingo, 1=Lunes, ..., 6=S√°bado
        }

        // Mapear d√≠a de la semana a c√≥digo
        function getDayCode(dayNumber) {
            const dayMap = {
                0: 'sun',
                1: 'mon',
                2: 'tue',
                3: 'wed',
                4: 'thu',
                5: 'fri',
                6: 'sat'
            };
            return dayMap[dayNumber];
        }

        // Obtener inicio de la semana actual (Lunes)
        function getStartOfWeek(date = new Date()) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Ajustar cuando es domingo
            return new Date(d.setDate(diff));
        }

        // Obtener fin de la semana actual (Domingo)
        function getEndOfWeek(date = new Date()) {
            const start = getStartOfWeek(date);
            const end = new Date(start);
            end.setDate(start.getDate() + 6);
            return end;
        }

        // Renderizar BUILD REVIEW
        function renderBuildReview() {
            const container = document.getElementById('buildReviewContent');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para esta semana</div>';
                return;
            }

            // Filtrar notas de la semana actual
            const weekStart = getStartOfWeek();
            const weekEnd = getEndOfWeek();
            weekEnd.setHours(23, 59, 59, 999);

            let filteredNotes = notes.filter(note => {
                const noteDate = new Date(note.buildReviewDate);
                return noteDate >= weekStart && noteDate <= weekEnd;
            });

            // Filtrar por d√≠a seleccionado
            if (buildReviewSelectedDay !== 'all') {
                filteredNotes = filteredNotes.filter(note => {
                    const dayOfWeek = getDayOfWeek(note.buildReviewDate);
                    const dayCode = getDayCode(dayOfWeek);
                    return dayCode === buildReviewSelectedDay;
                });
            }

            // Filtrar ocultar aceptados
            if (buildReviewHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para este d√≠a</div>';
                return;
            }

            // Renderizar lista simple
            let html = '<div style="padding: 10px;">';
            filteredNotes.forEach(note => {
                const dayOfWeek = getDayOfWeek(note.buildReviewDate);
                const dayCode = getDayCode(dayOfWeek);
                const dayNames = {
                    'mon': 'Lunes',
                    'tue': 'Martes',
                    'wed': 'Mi√©rcoles',
                    'thu': 'Jueves',
                    'fri': 'Viernes',
                    'sat': 'S√°bado',
                    'sun': 'Domingo'
                };

                html += `<div style="background: #0f0f1a; padding: 15px; margin-bottom: 10px; border-radius: 5px; border-left: 3px solid #00ff88;">`;

                // Mostrar d√≠a si estamos en vista "TODOS"
                if (buildReviewSelectedDay === 'all') {
                    html += `<div style="color: #888; font-size: 0.85rem; margin-bottom: 5px;">${dayNames[dayCode]}</div>`;
                }

                html += `<div style="color: #eee; margin-bottom: 10px;">${escapeHtml(note.text)}</div>`;

                // Mostrar categor√≠a y tags si ya fueron procesados
                if (note.aiProcessed) {
                    html += `<div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">`;
                    html += `<span style="background: #16213e; color: #00ff88; padding: 3px 8px; border-radius: 3px; font-size: 0.85rem;">${note.category}</span>`;
                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            html += `<span style="background: #1a1a2e; color: #888; padding: 3px 8px; border-radius: 3px; font-size: 0.85rem;">${tag}</span>`;
                        });
                    }
                    html += `</div>`;
                }

                html += `</div>`;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        // Roll-over semanal: mover notas no aceptadas al lunes actual
        async function performWeeklyRollover() {
            const today = new Date();
            const dayOfWeek = today.getDay();

            // Solo ejecutar el roll-over los lunes (d√≠a 1)
            if (dayOfWeek !== 1) {
                return;
            }

            // Obtener la semana actual (n√∫mero de semana del a√±o)
            const weekNumber = getWeekNumber(today);
            const lastRolloverWeek = localStorage.getItem('lastRolloverWeek');

            // Si ya se hizo el roll-over esta semana, salir
            if (lastRolloverWeek && parseInt(lastRolloverWeek) === weekNumber) {
                console.log('‚úÖ Roll-over ya ejecutado esta semana');
                return;
            }

            console.log('üîÑ Ejecutando roll-over semanal...');

            // Obtener inicio de la semana actual (este lunes)
            const thisMonday = getStartOfWeek(today);

            // Buscar notas NO aceptadas de semanas anteriores
            let notesRolledOver = 0;
            notes.forEach(note => {
                const noteDate = new Date(note.buildReviewDate);

                // Si la nota es de una semana anterior Y NO est√° aceptada
                if (noteDate < thisMonday && note.reviewStatus !== 'accepted') {
                    // Mover al lunes de esta semana
                    note.buildReviewDate = thisMonday.toISOString();
                    notesRolledOver++;
                }
            });

            // Guardar que ya se hizo el roll-over esta semana
            localStorage.setItem('lastRolloverWeek', weekNumber.toString());

            if (notesRolledOver > 0) {
                console.log(`‚úÖ Roll-over completado: ${notesRolledOver} notas movidas al lunes`);
                await saveToLocalStorage();
            } else {
                console.log('‚úÖ Roll-over completado: no hay notas para mover');
            }
        }

        // Obtener n√∫mero de semana del a√±o
        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        // Renderizar modo revisi√≥n
        function renderReviewMode() {
            const container = document.getElementById('reviewContent');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para revisar</div>';
                return;
            }

            // Filtrar notas
            let filteredNotes = notes;

            // Filtro por texto de b√∫squeda
            if (reviewFilterText) {
                filteredNotes = filteredNotes.filter(note => {
                    // Buscar en el texto de la nota
                    if (note.text.toLowerCase().includes(reviewFilterText)) return true;
                    // Buscar en la categor√≠a
                    if (note.category && note.category.toLowerCase().includes(reviewFilterText)) return true;
                    // Buscar en los tags
                    if (note.tags && note.tags.some(tag => tag.toLowerCase().includes(reviewFilterText))) return true;
                    // Buscar en las personas asignadas
                    if (note.assignedTo && note.assignedTo.some(person => person.toLowerCase().includes(reviewFilterText))) return true;
                    return false;
                });
            }

            // Filtro por persona
            if (reviewFilterPerson) {
                filteredNotes = filteredNotes.filter(note => {
                    return note.assignedTo && note.assignedTo.includes(reviewFilterPerson);
                });
            }

            // Filtro para ocultar aceptados
            if (reviewHideAccepted) {
                filteredNotes = filteredNotes.filter(note => {
                    return note.reviewStatus !== 'accepted';
                });
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No se encontraron notas con ese filtro</div>';
                return;
            }

            let html = '';

            if (reviewGroupByPerson) {
                // Agrupar por persona
                const byPerson = {};
                const unassigned = [];

                filteredNotes.forEach(note => {
                    if (note.assignedTo && note.assignedTo.length > 0) {
                        note.assignedTo.forEach(person => {
                            // Si hay un filtro de persona activo, solo mostrar esa persona
                            if (reviewFilterPerson && person !== reviewFilterPerson) {
                                return; // Saltar esta persona
                            }
                            if (!byPerson[person]) byPerson[person] = [];
                            byPerson[person].push(note);
                        });
                    } else {
                        unassigned.push(note);
                    }
                });

                // Renderizar por persona
                const sortedPeople = Object.keys(byPerson).sort();
                sortedPeople.forEach(person => {
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>üë§ ${person}</span>
                            <span class="review-person-count">${byPerson[person].length} tarea${byPerson[person].length !== 1 ? 's' : ''}</span>
                        </div>`;
                    byPerson[person].forEach(note => {
                        html += renderReviewItem(note);
                    });
                    html += `</div>`;
                });

                // Sin asignar
                if (unassigned.length > 0) {
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>üìã Sin Asignar</span>
                            <span class="review-person-count">${unassigned.length} tarea${unassigned.length !== 1 ? 's' : ''}</span>
                        </div>`;
                    unassigned.forEach(note => {
                        html += renderReviewItem(note);
                    });
                    html += `</div>`;
                }
            } else {
                // Agrupar por categor√≠a y tags
                const grouped = {};
                filteredNotes.forEach(note => {
                    const category = note.category || 'Other';
                    if (!grouped[category]) grouped[category] = {};

                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            if (!grouped[category][tag]) grouped[category][tag] = [];
                            grouped[category][tag].push(note);
                        });
                    } else {
                        if (!grouped[category]['General']) grouped[category]['General'] = [];
                        grouped[category]['General'].push(note);
                    }
                });

                // Renderizar por categor√≠a
                Object.entries(grouped).forEach(([category, tagGroups]) => {
                    const totalInCategory = Object.values(tagGroups).flat().length;
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>${getCategoryEmoji(category)} ${category}</span>
                            <span class="review-person-count">${totalInCategory} tarea${totalInCategory !== 1 ? 's' : ''}</span>
                        </div>`;

                    Object.entries(tagGroups).forEach(([tag, tagNotes]) => {
                        html += `<div style="margin-bottom: 30px;">
                            <div style="color: #888; font-size: 1rem; font-weight: bold; margin-bottom: 15px; padding-left: 10px; border-left: 3px solid #888;">
                                ${tag} <span style="color: #666; font-weight: normal;">(${tagNotes.length})</span>
                            </div>`;
                        tagNotes.forEach(note => {
                            html += renderReviewItem(note);
                        });
                        html += `</div>`;
                    });

                    html += `</div>`;
                });
            }

            container.innerHTML = html;
        }

        // Renderizar un item de revisi√≥n
        function renderReviewItem(note) {
            const currentStatus = note.workStatus || 'not_started';
            const statusColor = workStatusColors[currentStatus];
            const statusLabel = workStatusLabels[currentStatus];

            let html = `<div class="review-item">`;

            // ===== STATUS ARRIBA (muy separado) =====
            html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #1a1a2e;">`;

            // Status actual (clickeable para dropdown)
            html += `<div style="position: relative;">
                <div class="work-status-badge"
                     onclick="toggleWorkStatusSelector(${note.id}, event)"
                     style="background: ${statusColor}; cursor: pointer; font-size: 1rem; padding: 8px 16px;">
                    ${statusLabel}
                </div>

                <!-- Dropdown de estados -->
                <div class="work-status-selector" id="work-status-selector-${note.id}">
                    <button class="work-status-option" style="background: ${workStatusColors.not_started};" onclick="setWorkStatus(${note.id}, 'not_started', event)">‚≠ï NO EMPEZADO</button>
                    <button class="work-status-option" style="background: ${workStatusColors.wip};" onclick="setWorkStatus(${note.id}, 'wip', event)">üîÑ WIP</button>
                    <button class="work-status-option" style="background: ${workStatusColors.awaiting_review};" onclick="setWorkStatus(${note.id}, 'awaiting_review', event)">‚è≥ ESPERANDO REVISI√ìN</button>
                    <button class="work-status-option" style="background: ${workStatusColors.accepted};" onclick="setWorkStatus(${note.id}, 'accepted', event)">‚úÖ ACEPTADO</button>
                    <button class="work-status-option" style="background: ${workStatusColors.rejected};" onclick="setWorkStatus(${note.id}, 'rejected', event)">‚ùå RECHAZADO</button>
                </div>
            </div>`;

            // Bot√≥n de siguiente estado
            if (currentStatus === 'not_started') {
                html += `<button onclick="advanceWorkStatus(${note.id})" style="padding: 8px 16px; background: ${workStatusColors.wip}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.95rem;">‚ñ∂ Empezar</button>`;
            } else if (currentStatus === 'wip') {
                html += `<button onclick="advanceWorkStatus(${note.id})" style="padding: 8px 16px; background: ${workStatusColors.awaiting_review}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.95rem;">‚úì Listo para Revisi√≥n</button>`;
            } else if (currentStatus === 'awaiting_review') {
                html += `<button onclick="setWorkStatus(${note.id}, 'accepted', event)" style="padding: 6px 12px; background: ${workStatusColors.accepted}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.9rem; margin-right: 5px;">‚úì Aceptar</button>`;
                html += `<button onclick="setWorkStatus(${note.id}, 'rejected', event)" style="padding: 6px 12px; background: ${workStatusColors.rejected}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.9rem;">‚úó Rechazar</button>`;
            }

            html += `</div>`;

            // ===== TEXTO DE LA NOTA =====
            html += `<div class="review-item-text" style="margin-bottom: 15px; font-size: 1.05rem;">${escapeHtml(note.text)}</div>`;

            // ===== TODO LO DEM√ÅS ABAJO =====
            html += `<div class="review-item-meta" style="display: flex; gap: 8px; flex-wrap: wrap;">`;

            // Categor√≠a
            if (note.category) {
                html += `<span class="review-meta-badge">${getCategoryEmoji(note.category)} ${note.category}</span>`;
            }

            // Tags
            if (note.tags && note.tags.length > 0) {
                note.tags.forEach(tag => {
                    html += `<span class="review-meta-badge">${tag}</span>`;
                });
            }

            // Personas asignadas
            if (note.assignedTo && note.assignedTo.length > 0) {
                note.assignedTo.forEach(person => {
                    const personColor = personColors[person] || '#ff88ff';
                    html += `<span class="review-meta-badge" style="background: ${personColor}; color: #000; font-weight: bold;">üë§ ${person}</span>`;
                });
            }

            // Dificultad
            if (note.difficulty) {
                html += `<span class="review-meta-badge" style="background: #1a3a2e;">üìä ${note.difficulty.toUpperCase()}</span>`;
            }

            // Prioridad
            if (note.priority) {
                html += `<span class="review-meta-badge" style="background: ${getPriorityColor(note.priority)};">‚ö° <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>`;
            }

            html += `</div>`;

            // Comentario de rechazo si existe
            if (note.workStatus === 'rejected' && note.rejectionComment) {
                html += `<div class="review-comment-display" style="margin-top: 10px;">
                    <strong>Comentario:</strong> ${escapeHtml(note.rejectionComment)}
                </div>`;
            }

            html += `</div>`;
            return html;
        }

        // Avanzar al siguiente estado de trabajo
        function advanceWorkStatus(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex === -1) return;

            const currentStatus = notes[noteIndex].workStatus || 'not_started';
            let nextStatus = currentStatus;

            if (currentStatus === 'not_started') {
                nextStatus = 'wip';
            } else if (currentStatus === 'wip') {
                nextStatus = 'awaiting_review';
            }

            notes[noteIndex].workStatus = nextStatus;
            saveToLocalStorage();
            addToHistory('work_status', `"${notes[noteIndex].text}" ‚Üí ${workStatusLabels[nextStatus]}`);
            renderReviewMode();
        }

        // Aceptar nota
        function acceptNote(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].reviewStatus = 'accepted';
                notes[noteIndex].rejectionComment = '';
                saveToLocalStorage();
                addToHistory('review', `Aceptada: "${notes[noteIndex].text}"`);
                renderReviewMode();
            }
        }

        // Mostrar input para rechazar nota
        function showRejectInput(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex === -1) return;

            // Renderizar de nuevo mostrando el input
            const container = document.getElementById('reviewContent');
            const currentScroll = container.scrollTop;

            renderReviewMode();

            // Buscar el item y agregar el input
            const items = container.querySelectorAll('.review-item');
            let targetItem = null;

            // Encontrar el item correcto por su texto
            for (const item of items) {
                const textDiv = item.querySelector('.review-item-text');
                if (textDiv && textDiv.textContent === notes[noteIndex].text) {
                    targetItem = item;
                    break;
                }
            }

            if (targetItem) {
                const actionsDiv = targetItem.querySelector('.review-actions');
                if (actionsDiv) {
                    actionsDiv.innerHTML = `
                        <input type="text"
                               class="review-comment-input"
                               id="reject-comment-${noteId}"
                               placeholder="Ingresa el comentario y presiona Enter..."
                               onkeypress="if(event.key==='Enter') saveRejection(${noteId}, this.value)"
                               style="width: 100%; margin-top: 10px;">
                    `;

                    // Auto-focus y mantener scroll
                    setTimeout(() => {
                        const input = document.getElementById(`reject-comment-${noteId}`);
                        if (input) {
                            input.focus();
                            container.scrollTop = currentScroll;
                        }
                    }, 50);
                }
            }
        }

        // Guardar rechazo con comentario
        function saveRejection(noteId, comment) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].reviewStatus = 'rejected';
                notes[noteIndex].rejectionComment = comment.trim();
                saveToLocalStorage();
                addToHistory('review', `Rechazada: "${notes[noteIndex].text}" - ${comment}`);
                renderReviewMode();
            }
        }

        // Inicializar
        async function init() {
            await loadFromLocalStorage();

            // Ejecutar roll-over semanal (solo lunes, solo una vez por semana)
            await performWeeklyRollover();

            // Detectar si hay un par√°metro person en la URL
            const urlParams = new URLSearchParams(window.location.search);
            const personParam = urlParams.get('person');

            if (personParam) {
                // Modo personal: activar modo revisi√≥n con filtro de persona
                const personUpper = personParam.toUpperCase();
                if (people.includes(personUpper)) {
                    // Desactivar BUILD REVIEW y activar REVIEW MODE
                    buildReviewMode = false;
                    reviewMode = true;
                    reviewFilterPerson = personUpper;
                    reviewGroupByPerson = true;

                    // Actualizar botones
                    document.getElementById('buildReviewModeBtn').classList.remove('active');
                    document.getElementById('buildReviewPanel').classList.remove('active');
                    document.getElementById('reviewModeBtn').classList.add('active');
                    document.getElementById('reviewPanel').classList.add('active');
                    document.querySelector('.main-container').classList.add('review-active');

                    renderPersonFilters();
                    renderReviewMode();
                    return; // No continuar con la inicializaci√≥n normal
                }
            }

            // Vista de notas organizadas es el modo default
            renderNotes();
            renderHistory();

            // Configurar Enter para agregar nota
            const input = document.getElementById('terminalInput');
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addNote(); // NO AWAIT - no bloquear
                }
            });

            // Configurar Enter para agregar nota desde BUILD REVIEW
            const buildReviewInput = document.getElementById('buildReviewInput');
            buildReviewInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addNote(); // NO AWAIT - no bloquear
                }
            });

            // Mantener focus en el input (solo si no hay selecci√≥n de texto)
            document.addEventListener('click', (e) => {
                const hasSelection = window.getSelection().toString().length > 0;
                if (!hasSelection && !e.target.closest('.note-card') && !e.target.closest('.history-panel') && !e.target.closest('.delete-btn')) {
                    input.focus();
                }
            });
        }

        // Agregar nota - NO ASYNC
        function addNote() {
            const mainInput = document.getElementById('terminalInput');
            const buildInput = document.getElementById('buildReviewInput');

            // Intentar obtener texto de ambos inputs
            let text = '';
            let activeInput = null;

            if (mainInput && mainInput.value.trim()) {
                text = mainInput.value.trim();
                activeInput = mainInput;
            } else if (buildInput && buildInput.value.trim()) {
                text = buildInput.value.trim();
                activeInput = buildInput;
            }

            if (!text) return;

            // Crear nota inmediatamente
            const note = {
                id: Date.now(),
                text: text,
                category: 'Other', // Default inmediato
                tags: [],
                priority: null, // Sin prioridad por defecto
                difficulty: null, // Sin dificultad por defecto
                assignedTo: [], // Sin asignaciones por defecto
                reviewStatus: null, // 'accepted' | 'rejected' | null
                rejectionComment: '', // Comentario si fue rechazado
                workStatus: 'not_started', // Estado de trabajo
                timestamp: new Date().toISOString(),
                buildReviewDate: new Date().toISOString(), // Fecha de build review
                aiProcessed: false
            };

            notes.push(note);
            addTerminalLine(text, note.id);

            // Limpiar input INMEDIATAMENTE
            activeInput.value = '';
            activeInput.focus();

            // Guardar y renderizar INMEDIATAMENTE
            saveToLocalStorage();
            renderNotes();
            if (buildReviewMode) {
                renderBuildReview(); // Actualizar BUILD REVIEW tambi√©n
            }

            // Procesar con AI en background (no bloquea)
            processWithAI(note); // Sin await - corre en background
        }

        // Agregar l√≠nea al terminal
        function addTerminalLine(text, noteId) {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            line.id = `line-${noteId}`;
            renderTerminalLine(line, noteId, text);
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        // Renderizar contenido de l√≠nea terminal
        function renderTerminalLine(lineElement, noteId, text) {
            const note = notes.find(n => n.id === noteId);
            if (!note) return;

            // Verificar si esta nota espec√≠fica est√° colapsada (ya se le dio aceptar)
            const isCollapsed = collapsedAssignments.has(noteId);

            // Verificar si est√° en modo de edici√≥n de asignaci√≥n
            const isEditingAssignment = editingAssignments.has(noteId);

            // Verificar si la tarea ya tiene asignaciones
            const hasAssignments = (note.assignedTo && note.assignedTo.length > 0) || note.difficulty || note.priority;

            // Mostrar UI de asignaci√≥n solo si:
            // - Estamos en modo asignaci√≥n
            // - NO est√° colapsada
            // - NO tiene asignaciones previas O est√° en modo de edici√≥n
            const showAssignmentUI = assignmentMode && !isCollapsed && (!hasAssignments || isEditingAssignment);

            // Mostrar vista de asignaci√≥n existente con opci√≥n de editar si:
            // - Estamos en modo asignaci√≥n
            // - NO est√° colapsada
            // - S√ç tiene asignaciones previas
            // - NO est√° en modo de edici√≥n
            const showAssignedWithEdit = assignmentMode && !isCollapsed && hasAssignments && !isEditingAssignment;

            lineElement.innerHTML = `
                <div class="terminal-line-main">
                    <div class="terminal-line-text">
                        <span class="prompt">></span>
                        <span class="text">${escapeHtml(text)}</span>
                    </div>
                    <div class="ai-processing" id="status-${noteId}" style="color: #ffa500; font-size: 0.85rem;">ü§ñ AI procesando...</div>
                </div>
                ${showAssignmentUI ? `
                    <div class="assignment-section" id="assignment-terminal-${noteId}" style="margin-top: 8px;">
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">üë• ASIGNAR A:</div>
                            <div class="assignment-people">
                                ${people.map(person => `
                                    <label class="person-checkbox ${note.assignedTo && note.assignedTo.includes(person) ? 'selected' : ''}" onclick="togglePerson(${noteId}, '${person}', event)">
                                        <input type="checkbox" value="${person}" ${note.assignedTo && note.assignedTo.includes(person) ? 'checked' : ''}>
                                        ${person}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">üìä DIFICULTAD:</div>
                            <div class="assignment-people">
                                ${difficulties.map(diff => `
                                    <label class="person-checkbox ${note.difficulty === diff.toLowerCase() ? 'selected' : ''}" onclick="selectDifficulty(${noteId}, '${diff.toLowerCase()}', event)">
                                        <input type="radio" name="difficulty-${noteId}" value="${diff.toLowerCase()}" ${note.difficulty === diff.toLowerCase() ? 'checked' : ''}>
                                        ${diff}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">‚ö° PRIORIDAD:</div>
                            <div class="assignment-people">
                                ${priorities.map(prio => `
                                    <label class="person-checkbox ${note.priority === prio.toLowerCase() ? 'selected' : ''}" onclick="selectPriority(${noteId}, '${prio.toLowerCase()}', event)">
                                        <input type="radio" name="priority-${noteId}" value="${prio.toLowerCase()}" ${note.priority === prio.toLowerCase() ? 'checked' : ''}>
                                        ${prio}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <button class="save-btn" onclick="assignPeople(${noteId}, event)">‚úì Aceptar</button>
                    </div>
                ` : showAssignedWithEdit ? `
                    <div style="margin-top: 6px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                        ${note.assignedTo && note.assignedTo.length > 0 ? `
                            ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">üë§ ${person}</span>`).join('')}
                        ` : ''}
                        ${note.difficulty ? `<span class="assigned-person" style="background: #1a3a2e; border-color: #00ff8888;">üìä ${note.difficulty.toUpperCase()}</span>` : ''}
                        ${note.priority ? `<span class="assigned-person" style="background: ${getPriorityColor(note.priority)}; border-color: ${getPriorityColor(note.priority)};">‚ö° <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>` : ''}
                        <button class="edit-btn" onclick="enableAssignmentEdit(${noteId}, event)" style="margin-left: 4px; padding: 4px 8px; font-size: 0.8rem;" title="Editar asignaci√≥n">‚úé</button>
                    </div>
                ` : hasAssignments ? `
                    <div style="margin-top: 6px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                        ${note.assignedTo && note.assignedTo.length > 0 ? `
                            ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">üë§ ${person}</span>`).join('')}
                        ` : ''}
                        ${note.difficulty ? `<span class="assigned-person" style="background: #1a3a2e; border-color: #00ff8888;">üìä ${note.difficulty.toUpperCase()}</span>` : ''}
                        ${note.priority ? `<span class="assigned-person" style="background: ${getPriorityColor(note.priority)}; border-color: ${getPriorityColor(note.priority)};">‚ö° <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>` : ''}
                    </div>
                ` : ''}
            `;
        }

        // Actualizar estado en terminal
        function updateTerminalLine(noteId, message, isError = false, category = null, tags = null) {
            const status = document.getElementById(`status-${noteId}`);
            if (status) {
                if (category && tags) {
                    // Mostrar con badges visuales
                    const tagsHtml = tags.length > 0
                        ? tags.map(tag => `<span class="terminal-tag">${tag}</span>`).join('')
                        : '';
                    status.innerHTML = `
                        <div class="ai-result">
                            <span style="color: #00ff88;">‚úì</span>
                            <span class="terminal-category-badge">${getCategoryEmoji(category)} ${category}</span>
                            ${tagsHtml}
                        </div>
                    `;
                } else {
                    // Mostrar mensaje simple
                    status.textContent = message;
                    status.style.color = isError ? '#e94560' : '#00ff88';
                }
            }
        }

        // Procesar con AI - async pero no bloquea
        async function processWithAI(note) {
            console.log('ü§ñ Procesando con AI:', note.text);

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                // TODO: Migrar a Supabase Edge Function
                // const response = await fetch('/api/categorize', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json'
                //     },
                //     body: JSON.stringify({ text: note.text }),
                //     signal: controller.signal
                // });

                // Por ahora: categorizaci√≥n manual (temporal)
                throw new Error('AI categorization temporalmente deshabilitada - usa categor√≠a manual');

                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Error de la API:', errorText);
                    throw new Error(`API returned ${response.status}`);
                }

                // Intentar parsear JSON con mejor manejo de errores
                let data;
                try {
                    const textResponse = await response.text();
                    if (!textResponse || textResponse.trim().length === 0) {
                        throw new Error('Respuesta vac√≠a de la API');
                    }
                    data = JSON.parse(textResponse);
                    console.log('üì¶ Respuesta API completa:', data);
                } catch (parseError) {
                    console.error('‚ùå Error parseando JSON:', parseError);
                    throw new Error('Respuesta inv√°lida de la API');
                }

                // Verificar estructura de la respuesta
                if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                    console.error('‚ùå Respuesta sin contenido:', data);
                    throw new Error('Respuesta sin contenido');
                }

                if (!data.content[0] || !data.content[0].text) {
                    console.error('‚ùå Formato de respuesta inv√°lido:', data);
                    throw new Error('Formato inv√°lido');
                }

                const content = data.content[0].text.trim();
                console.log('üìù Texto de respuesta:', content);

                const jsonMatch = content.match(/\{[\s\S]*\}/);
                console.log('üîç JSON extra√≠do:', jsonMatch ? jsonMatch[0] : 'NO MATCH');

                if (!jsonMatch) {
                    throw new Error('Sin JSON en respuesta');
                }

                const suggestion = JSON.parse(jsonMatch[0]);
                console.log('‚úÖ Objeto parseado:', suggestion);
                console.log('  ‚Üí Category:', suggestion.category);
                console.log('  ‚Üí Tags:', suggestion.tags);

                // Actualizar nota
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].category = suggestion.category || 'Other';
                    notes[noteIndex].tags = suggestion.tags || [];
                    notes[noteIndex].aiProcessed = true;

                    // Actualizar terminal con badges visuales
                    updateTerminalLine(note.id, null, false, suggestion.category, suggestion.tags || []);

                    const tagStr = suggestion.tags?.length > 0 ? ` [${suggestion.tags.join(', ')}]` : '';
                    addToHistory('add', `"${note.text}" ‚Üí ${suggestion.category}${tagStr}`);

                    saveToLocalStorage();
                    renderNotes();
                }

            } catch (error) {
                console.error('‚ùå AI Error completo:', error);
                console.error('‚ùå Error name:', error.name);
                console.error('‚ùå Error message:', error.message);
                console.error('‚ùå Error stack:', error.stack);

                updateTerminalLine(note.id, `‚ö†Ô∏è Error: ${error.message}`, true);

                // Ya est√° guardada como "Other", solo marcar como procesada
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].aiProcessed = true;
                    saveToLocalStorage();
                }
            }
        }

        // Eliminar nota
        function deleteNote(id, event) {
            event.stopPropagation();
            const note = notes.find(n => n.id === id);
            if (note && confirm('¬øEliminar esta nota?')) {
                addToHistory('delete', `Eliminada: "${note.text}"`);
                notes = notes.filter(n => n.id !== id);

                const line = document.getElementById(`line-${id}`);
                if (line) line.remove();

                saveToLocalStorage();
                renderNotes();
            }
        }

        // Editar nota
        let editingNoteId = null;

        function startEditNote(id, event) {
            event.stopPropagation();
            editingNoteId = id;
            renderNotes();
        }

        function saveEditNote(id, event) {
            event.stopPropagation();
            const input = document.getElementById(`edit-input-${id}`);
            const newText = input.value.trim();

            if (!newText) {
                alert('La nota no puede estar vac√≠a');
                return;
            }

            const noteIndex = notes.findIndex(n => n.id === id);
            if (noteIndex !== -1) {
                const oldText = notes[noteIndex].text;
                notes[noteIndex].text = newText;
                notes[noteIndex].aiProcessed = false;

                addToHistory('edit', `Editada: "${oldText}" ‚Üí "${newText}"`);

                // Actualizar terminal
                const line = document.getElementById(`line-${id}`);
                if (line) {
                    const textSpan = line.querySelector('.text');
                    if (textSpan) textSpan.textContent = newText;
                    updateTerminalLine(id, 'ü§ñ AI procesando...', false);
                }

                saveToLocalStorage();
                editingNoteId = null;
                renderNotes();

                // Re-procesar con AI
                processWithAI(notes[noteIndex]);
            }
        }

        function cancelEditNote(event) {
            event.stopPropagation();
            editingNoteId = null;
            renderNotes();
        }

        // Cambiar prioridad
        function togglePrioritySelector(noteId, event) {
            event.stopPropagation();

            // Cerrar otros selectores
            document.querySelectorAll('.priority-selector').forEach(s => s.classList.remove('active'));

            const selector = document.getElementById(`priority-selector-${noteId}`);
            if (selector) {
                selector.classList.toggle('active');
            }
        }

        function setPriority(noteId, priority, event) {
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].priority = priority;
                saveToLocalStorage();
                renderNotes();
                addToHistory('priority', `Prioridad ${priority.toUpperCase()} para "${notes[noteIndex].text}"`);
            }

            // Cerrar selector
            const selector = document.getElementById(`priority-selector-${noteId}`);
            if (selector) {
                selector.classList.remove('active');
            }
        }

        // Cambiar estado de trabajo
        function toggleWorkStatusSelector(noteId, event) {
            event.stopPropagation();

            // Cerrar otros selectores
            document.querySelectorAll('.work-status-selector').forEach(s => s.classList.remove('active'));

            const selector = document.getElementById(`work-status-selector-${noteId}`);
            if (selector) {
                selector.classList.toggle('active');
            }
        }

        function setWorkStatus(noteId, status, event) {
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].workStatus = status;
                saveToLocalStorage();
                renderNotes();
                renderReviewMode();
                addToHistory('work-status', `Estado "${workStatusLabels[status]}" para "${notes[noteIndex].text}"`);
            }

            // Cerrar selector
            const selector = document.getElementById(`work-status-selector-${noteId}`);
            if (selector) {
                selector.classList.remove('active');
            }
        }

        // Cerrar selectores al hacer click fuera
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.priority-badge') && !e.target.closest('.priority-selector')) {
                document.querySelectorAll('.priority-selector').forEach(s => s.classList.remove('active'));
            }
            if (!e.target.closest('.work-status-badge') && !e.target.closest('.work-status-selector')) {
                document.querySelectorAll('.work-status-selector').forEach(s => s.classList.remove('active'));
            }
        });

        // Recategorizar y agrupar todas las notas
        async function recategorizeAndGroup() {
            if (notes.length === 0) {
                alert('No hay notas para recategorizar');
                return;
            }

            // Filtrar solo las que no tienen categor√≠a o est√°n en "Other"
            const notesToRecategorize = notes.filter(note => !note.category || note.category === 'Other');

            if (notesToRecategorize.length === 0) {
                alert('No hay notas sin categor√≠a o en "Other" para recategorizar');
                return;
            }

            if (!confirm(`¬øRecategorizar ${notesToRecategorize.length} nota${notesToRecategorize.length !== 1 ? 's' : ''} sin categor√≠a o en "Other" con AI?\n\nEsto reorganizar√° estas notas por categor√≠as y agrupar√° items similares con tags comunes.`)) {
                return;
            }

            console.log(`üîÑ Recategorizando y agrupando ${notesToRecategorize.length} notas...`);
            addToHistory('recategorize', `Recategorizando y agrupando ${notesToRecategorize.length} notas sin categor√≠a o en "Other"`);

            // Procesar solo las notas filtradas
            for (const note of notesToRecategorize) {
                console.log(`üîÑ Recategorizando: "${note.text}"`);
                updateTerminalLine(note.id, 'üîÑ Recategorizando y agrupando...', false);

                // Marcar como no procesada para que se re-procese
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].aiProcessed = false;
                }

                await processWithAI(note);

                // Peque√±a pausa para no saturar el API
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            console.log('‚úÖ Recategorizaci√≥n y agrupaci√≥n completa');
            addToHistory('recategorize', `Recategorizaci√≥n y agrupaci√≥n completada - items similares ahora tienen tags comunes`);
            alert('‚úÖ Recategorizaci√≥n completa!\n\nLas notas sin categor√≠a o en "Other" han sido reorganizadas por categor√≠as y las similares han sido agrupadas con tags comunes.');
        }

        // Borrar todas las notas
        function clearAllNotes() {
            if (notes.length === 0) {
                alert('No hay notas para borrar');
                return;
            }

            if (confirm(`¬øBorrar TODAS las ${notes.length} notas?`)) {
                addToHistory('clear', `Borradas ${notes.length} notas`);
                notes = [];

                const output = document.getElementById('terminalOutput');
                output.innerHTML = `
                    <div style="color: #00ff88; margin-bottom: 20px; font-size: 1.1rem;">
                        üí¨ Escribe tus notas y presiona Enter. La AI las organizar√° autom√°ticamente.
                    </div>
                `;

                saveToLocalStorage();
                renderNotes();
                document.getElementById('terminalInput').focus();
            }
        }

        // Toggle modo asignaci√≥n
        function toggleAssignmentMode() {
            assignmentMode = !assignmentMode;
            const btn = document.getElementById('assignmentModeBtn');
            const filterBar = document.getElementById('assignmentFilterBar');

            if (assignmentMode) {
                btn.classList.add('active');
                if (filterBar) filterBar.style.display = 'block';
                // Renderizar los filtros de personas
                renderAssignmentFilters();
                // Al entrar en modo asignaci√≥n, NO limpiar las colapsadas
                // Las tareas ya asignadas se muestran con icono de editar
            } else {
                btn.classList.remove('active');
                if (filterBar) filterBar.style.display = 'none';
                // Al salir del modo, limpiar las colapsadas y editingAssignments
                collapsedAssignments.clear();
                editingAssignments.clear();
            }

            // Re-renderizar todas las l√≠neas del terminal
            // En modo asignaci√≥n, ordenar para mostrar sin asignar primero y filtrar aceptados
            let notesToRender = notes;

            if (assignmentMode) {
                // Filtrar aceptados si el checkbox est√° marcado
                if (assignmentHideAccepted) {
                    notesToRender = notesToRender.filter(note => note.reviewStatus !== 'accepted');
                }

                // Ordenar: sin personas asignadas primero
                notesToRender = [...notesToRender].sort((a, b) => {
                    const aHasPeople = a.assignedTo && a.assignedTo.length > 0;
                    const bHasPeople = b.assignedTo && b.assignedTo.length > 0;
                    if (!aHasPeople && bHasPeople) return -1;
                    if (aHasPeople && !bHasPeople) return 1;
                    return 0;
                });
            }

            // Re-ordenar elementos en el DOM y ocultar los que no est√°n en la lista filtrada
            const terminalOutput = document.getElementById('terminalOutput');
            const notesToRenderIds = new Set(notesToRender.map(n => n.id));

            // Primero ocultar todas las l√≠neas que no est√°n en la lista filtrada
            notes.forEach(note => {
                const lineElement = document.getElementById(`line-${note.id}`);
                if (lineElement) {
                    if (!notesToRenderIds.has(note.id)) {
                        lineElement.style.display = 'none';
                    } else {
                        lineElement.style.display = 'block';
                    }
                }
            });

            // Luego re-ordenar y renderizar las visibles
            notesToRender.forEach(note => {
                const lineElement = document.getElementById(`line-${note.id}`);
                if (lineElement) {
                    // Mover al final para mantener orden
                    terminalOutput.appendChild(lineElement);
                    renderTerminalLine(lineElement, note.id, note.text);
                    // Restaurar estado de AI si ya fue procesado
                    if (note.aiProcessed) {
                        updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                    }
                }
            });

            renderNotes();
        }

        // Toggle ocultar aceptados en modo asignaci√≥n
        function toggleAssignmentHideAccepted() {
            const checkbox = document.getElementById('assignmentHideAcceptedCheckbox');
            assignmentHideAccepted = checkbox.checked;

            // Re-renderizar filtros para mantener el estado del checkbox sincronizado
            renderAssignmentFilters();

            // Re-renderizar notas con el filtro actualizado
            renderNotes();

            // Solo re-renderizar terminal si estamos en modo asignaci√≥n
            if (assignmentMode) {
                // Re-renderizar todas las l√≠neas del terminal con el filtro actualizado
                let notesToRender = notes;

                // Filtrar aceptados si el checkbox est√° marcado
                if (assignmentHideAccepted) {
                    notesToRender = notesToRender.filter(note => note.reviewStatus !== 'accepted');
                }

                // Ordenar: sin personas asignadas primero
                notesToRender = [...notesToRender].sort((a, b) => {
                    const aHasPeople = a.assignedTo && a.assignedTo.length > 0;
                    const bHasPeople = b.assignedTo && b.assignedTo.length > 0;
                    if (!aHasPeople && bHasPeople) return -1;
                    if (aHasPeople && !bHasPeople) return 1;
                    return 0;
                });

                // Re-ordenar elementos en el DOM y ocultar los que no est√°n en la lista filtrada
                const terminalOutput = document.getElementById('terminalOutput');
                const notesToRenderIds = new Set(notesToRender.map(n => n.id));

                // Primero ocultar todas las l√≠neas que no est√°n en la lista filtrada
                notes.forEach(note => {
                    const lineElement = document.getElementById(`line-${note.id}`);
                    if (lineElement) {
                        if (!notesToRenderIds.has(note.id)) {
                            lineElement.style.display = 'none';
                        } else {
                            lineElement.style.display = 'block';
                        }
                    }
                });

                // Luego re-ordenar las visibles
                notesToRender.forEach(note => {
                    const lineElement = document.getElementById(`line-${note.id}`);
                    if (lineElement) {
                        terminalOutput.appendChild(lineElement);
                    }
                });
            }
        }

        // Toggle selecci√≥n de persona
        function togglePerson(noteId, person, event) {
            event.stopPropagation();
            const checkbox = event.target.closest('.person-checkbox').querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;

            const label = event.target.closest('.person-checkbox');
            if (checkbox.checked) {
                label.classList.add('selected');
            } else {
                label.classList.remove('selected');
            }
        }

        // Seleccionar dificultad
        function selectDifficulty(noteId, difficulty, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS
            const escapedId = CSS.escape(String(noteId));

            // Desmarcar todos los radio buttons de dificultad
            const allRadios = document.querySelectorAll(`input[name="difficulty-${escapedId}"]`);
            allRadios.forEach(radio => {
                radio.checked = false;
                radio.closest('.person-checkbox').classList.remove('selected');
            });

            // Marcar el seleccionado
            const radio = event.target.closest('.person-checkbox').querySelector('input[type="radio"]');
            radio.checked = true;
            event.target.closest('.person-checkbox').classList.add('selected');
        }

        // Seleccionar prioridad
        function selectPriority(noteId, priority, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS
            const escapedId = CSS.escape(String(noteId));

            // Desmarcar todos los radio buttons de prioridad
            const allRadios = document.querySelectorAll(`input[name="priority-${escapedId}"]`);
            allRadios.forEach(radio => {
                radio.checked = false;
                radio.closest('.person-checkbox').classList.remove('selected');
            });

            // Marcar el seleccionado
            const radio = event.target.closest('.person-checkbox').querySelector('input[type="radio"]');
            radio.checked = true;
            event.target.closest('.person-checkbox').classList.add('selected');
        }

        // Obtener color de prioridad
        function getPriorityColor(priority) {
            const colors = {
                'low': '#00aaff',
                'medium': '#ffcc00',
                'high': '#ff6600',
                'critical': '#ff0040'
            };
            return colors[priority] || '#2e1a3a';
        }

        // Asignar personas a nota
        function assignPeople(noteId, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS (maneja puntos y caracteres especiales)
            const escapedId = CSS.escape(String(noteId));

            // Obtener personas seleccionadas
            const checkboxes = document.querySelectorAll(`#assignment-terminal-${escapedId} input[type="checkbox"]:checked`);
            const selectedPeople = Array.from(checkboxes).map(cb => cb.value);

            // Obtener dificultad seleccionada
            const difficultyRadio = document.querySelector(`input[name="difficulty-${escapedId}"]:checked`);
            const selectedDifficulty = difficultyRadio ? difficultyRadio.value : null;

            // Obtener prioridad seleccionada
            const priorityRadio = document.querySelector(`input[name="priority-${escapedId}"]:checked`);
            const selectedPriority = priorityRadio ? priorityRadio.value : null;

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].assignedTo = selectedPeople;
                notes[noteIndex].difficulty = selectedDifficulty;
                notes[noteIndex].priority = selectedPriority;

                saveToLocalStorage();

                // Log en historial
                const details = [];
                if (selectedPeople.length > 0) details.push(`üë• ${selectedPeople.join(', ')}`);
                if (selectedDifficulty) details.push(`üìä ${selectedDifficulty.toUpperCase()}`);
                if (selectedPriority) details.push(`‚ö° ${selectedPriority.toUpperCase()}`);

                const detailsStr = details.length > 0 ? details.join(' | ') : 'sin asignaciones';
                addToHistory('assign', `Asignada "${notes[noteIndex].text}" ‚Üí ${detailsStr}`);

                // Marcar esta nota como colapsada (cerrada) pero NO salir del modo de asignaci√≥n
                collapsedAssignments.add(noteId);
                // Remover del modo de edici√≥n
                editingAssignments.delete(noteId);

                // Re-renderizar SOLO esta l√≠nea del terminal
                const lineElement = document.getElementById(`line-${noteId}`);
                if (lineElement) {
                    renderTerminalLine(lineElement, noteId, notes[noteIndex].text);
                    // Restaurar estado de AI si ya fue procesado
                    if (notes[noteIndex].aiProcessed) {
                        updateTerminalLine(noteId, null, false, notes[noteIndex].category, notes[noteIndex].tags || []);
                    }
                }

                renderNotes();
            }
        }

        // Habilitar edici√≥n de asignaci√≥n para una tarea ya asignada
        function enableAssignmentEdit(noteId, event) {
            event.stopPropagation();

            // Remover de las colapsadas para mostrar la UI de asignaci√≥n
            collapsedAssignments.delete(noteId);

            // Agregar a editingAssignments para forzar mostrar la UI de asignaci√≥n
            editingAssignments.add(noteId);

            // Re-renderizar la l√≠nea del terminal para mostrar las opciones de asignaci√≥n
            const note = notes.find(n => n.id === noteId);
            if (note) {
                const lineElement = document.getElementById(`line-${noteId}`);
                if (lineElement) {
                    renderTerminalLine(lineElement, noteId, note.text);
                    // Restaurar estado de AI si ya fue procesado
                    if (note.aiProcessed) {
                        updateTerminalLine(noteId, null, false, note.category, note.tags || []);
                    }
                }
            }
        }

        // Funciones para asignaci√≥n en tarjetas (note cards)
        function togglePersonInCard(noteId, person, event) {
            event.preventDefault();
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                if (!notes[noteIndex].assignedTo) notes[noteIndex].assignedTo = [];
                const index = notes[noteIndex].assignedTo.indexOf(person);

                // Actualizar estado interno
                if (index > -1) {
                    notes[noteIndex].assignedTo.splice(index, 1);
                } else {
                    notes[noteIndex].assignedTo.push(person);
                }

                // Actualizar visualmente el checkbox sin re-renderizar todo
                const label = event.target.closest('label');
                const checkbox = label.querySelector('input[type="checkbox"]');
                checkbox.checked = notes[noteIndex].assignedTo.includes(person);

                // Actualizar clase CSS
                if (checkbox.checked) {
                    label.classList.add('selected');
                } else {
                    label.classList.remove('selected');
                }
            }
        }

        function selectDifficultyInCard(noteId, difficulty, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].difficulty = difficulty;
                // NO re-renderizar, dejar que el radio se maneje nativamente
            }
        }

        function selectPriorityInCard(noteId, priority, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].priority = priority;
                // NO re-renderizar, dejar que el radio se maneje nativamente
            }
        }

        function saveAssignmentInCard(noteId, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                // Guardar a base de datos
                saveToLocalStorage();

                // Log en historial
                const details = [];
                if (notes[noteIndex].assignedTo && notes[noteIndex].assignedTo.length > 0) {
                    details.push(`üë• ${notes[noteIndex].assignedTo.join(', ')}`);
                }
                if (notes[noteIndex].difficulty) details.push(`üìä ${notes[noteIndex].difficulty.toUpperCase()}`);
                if (notes[noteIndex].priority) details.push(`‚ö° ${notes[noteIndex].priority.toUpperCase()}`);

                const detailsStr = details.length > 0 ? details.join(' | ') : 'sin asignaciones';
                addToHistory('assign', `Asignada "${notes[noteIndex].text}" ‚Üí ${detailsStr}`);

                // Remover del modo de edici√≥n
                editingAssignments.delete(noteId);

                renderNotes();
            }
        }

        function editAssignmentInCard(noteId, event) {
            event.stopPropagation();
            // Agregar a editingAssignments para mostrar la UI de asignaci√≥n
            editingAssignments.add(noteId);
            renderNotes();
        }

        // Renderizar notas organizadas
        function renderNotes() {
            // Delegar seg√∫n el modo de vista
            if (assignmentViewMode === 'person') {
                renderNotesByPerson();
                return;
            }

            // Vista por categor√≠a (c√≥digo original)
            const container = document.getElementById('notesList');
            const countEl = document.getElementById('notesCount');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas a√∫n.<br>Empieza a escribir!</div>';
                countEl.textContent = '0 notas';
                return;
            }

            // Aplicar filtros de asignaci√≥n
            let filteredNotes = notes;

            // Filtrar por persona si est√° en modo asignaci√≥n
            if (assignmentMode && assignmentFilterPerson !== null) {
                filteredNotes = filteredNotes.filter(note =>
                    note.assignedTo && note.assignedTo.includes(assignmentFilterPerson)
                );
            }

            // Filtrar por texto
            if (assignmentMode && assignmentFilterText) {
                filteredNotes = filteredNotes.filter(note =>
                    note.text.toLowerCase().includes(assignmentFilterText) ||
                    (note.category && note.category.toLowerCase().includes(assignmentFilterText)) ||
                    (note.tags && note.tags.some(tag => tag.toLowerCase().includes(assignmentFilterText)))
                );
            }

            // Filtrar por ocultar aceptados
            if (assignmentMode && assignmentHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas que coincidan con los filtros.</div>';
                countEl.textContent = '0 notas';
                return;
            }

            countEl.textContent = `${filteredNotes.length} nota${filteredNotes.length !== 1 ? 's' : ''}`;

            // En modo asignaci√≥n, separar en dos grupos: sin asignar y con asignados
            let unassignedNotes = [];
            let assignedNotes = [];

            if (assignmentMode) {
                unassignedNotes = filteredNotes.filter(note => !note.assignedTo || note.assignedTo.length === 0);
                assignedNotes = filteredNotes.filter(note => note.assignedTo && note.assignedTo.length > 0);
            }

            // Agrupar por categor√≠a y tags
            const grouped = {};
            const notesToGroup = assignmentMode ? assignedNotes : filteredNotes;

            notesToGroup.forEach(note => {
                const category = note.category || 'Other';
                if (!grouped[category]) grouped[category] = {};

                if (note.tags && note.tags.length > 0) {
                    note.tags.forEach(tag => {
                        if (!grouped[category][tag]) grouped[category][tag] = [];
                        grouped[category][tag].push(note);
                    });
                } else {
                    if (!grouped[category]['General']) grouped[category]['General'] = [];
                    grouped[category]['General'].push(note);
                }
            });

            // Agrupar notas sin asignar (en modo asignaci√≥n)
            const unassignedGrouped = {};
            if (assignmentMode && unassignedNotes.length > 0) {
                unassignedNotes.forEach(note => {
                    const category = note.category || 'Other';
                    if (!unassignedGrouped[category]) unassignedGrouped[category] = {};

                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            if (!unassignedGrouped[category][tag]) unassignedGrouped[category][tag] = [];
                            unassignedGrouped[category][tag].push(note);
                        });
                    } else {
                        if (!unassignedGrouped[category]['General']) unassignedGrouped[category]['General'] = [];
                        unassignedGrouped[category]['General'].push(note);
                    }
                });
            }

            // Renderizar
            let html = '';

            // Primero: notas sin asignar (en modo asignaci√≥n)
            if (assignmentMode && Object.keys(unassignedGrouped).length > 0) {
                html += `<div style="background: rgba(255, 200, 0, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 30px; border: 2px solid rgba(255, 200, 0, 0.3);">
                    <div style="color: #ffc800; font-weight: bold; font-size: 1.2rem; margin-bottom: 20px;">
                        ‚ö†Ô∏è SIN ASIGNAR (${unassignedNotes.length})
                    </div>`;
                html += Object.entries(unassignedGrouped)
                    .map(([category, tagGroups]) => {
                        const totalInCategory = Object.values(tagGroups).flat().length;
                        return `
                            <div style="margin-bottom: 20px;">
                                <div style="color: #00ff88; font-weight: bold; font-size: 1rem; margin-bottom: 10px;">
                                    ${getCategoryEmoji(category)} ${category}
                                    <span style="color: #888; font-size: 0.85rem; margin-left: 10px;">(${totalInCategory})</span>
                                </div>
                                ${Object.entries(tagGroups).map(([tag, tagNotes]) => `
                                    <div class="tag-group">
                                        <div class="tag-group-header">
                                            <span>${tag}</span>
                                            <span class="tag-badge">${tagNotes.length}</span>
                                        </div>
                                        ${tagNotes.map(note => renderNoteCard(note)).join('')}
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    })
                    .join('');
                html += '</div>';
            }

            // Segundo: notas asignadas (o todas si no estamos en modo asignaci√≥n)
            html += Object.entries(grouped)
                .map(([category, tagGroups]) => {
                    const totalInCategory = Object.values(tagGroups).flat().length;
                    return `
                        <div style="margin-bottom: 30px;">
                            <div style="color: #00ff88; font-weight: bold; font-size: 1.1rem; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #16213e;">
                                ${getCategoryEmoji(category)} ${category}
                                <span style="color: #888; font-size: 0.85rem; margin-left: 10px;">(${totalInCategory})</span>
                            </div>
                            ${Object.entries(tagGroups).map(([tag, tagNotes]) => `
                                <div class="tag-group">
                                    <div class="tag-group-header">
                                        <span>${tag}</span>
                                        <span class="tag-badge">${tagNotes.length}</span>
                                    </div>
                                    ${tagNotes.map(note => renderNoteCard(note)).join('')}
                                </div>
                            `).join('')}
                        </div>
                    `;
                })
                .join('');

            container.innerHTML = html;
        }

        // Renderizar notas agrupadas por persona
        function renderNotesByPerson() {
            const container = document.getElementById('notesList');
            const countEl = document.getElementById('notesCount');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas a√∫n.<br>Empieza a escribir!</div>';
                countEl.textContent = '0 notas';
                return;
            }

            // Aplicar filtros de asignaci√≥n
            let filteredNotes = notes;

            // Filtrar por persona si est√° en modo asignaci√≥n
            if (assignmentMode && assignmentFilterPerson !== null) {
                filteredNotes = filteredNotes.filter(note =>
                    note.assignedTo && note.assignedTo.includes(assignmentFilterPerson)
                );
            }

            // Filtrar por texto
            if (assignmentMode && assignmentFilterText) {
                filteredNotes = filteredNotes.filter(note =>
                    note.text.toLowerCase().includes(assignmentFilterText) ||
                    (note.category && note.category.toLowerCase().includes(assignmentFilterText)) ||
                    (note.tags && note.tags.some(tag => tag.toLowerCase().includes(assignmentFilterText)))
                );
            }

            // Filtrar por ocultar aceptados
            if (assignmentMode && assignmentHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas que coincidan con los filtros.</div>';
                countEl.textContent = '0 notas';
                return;
            }

            countEl.textContent = `${filteredNotes.length} nota${filteredNotes.length !== 1 ? 's' : ''}`;

            // Agrupar notas por persona
            const groupedByPerson = {};
            const unassigned = [];

            filteredNotes.forEach(note => {
                if (note.assignedTo && note.assignedTo.length > 0) {
                    note.assignedTo.forEach(person => {
                        if (!groupedByPerson[person]) {
                            groupedByPerson[person] = [];
                        }
                        groupedByPerson[person].push(note);
                    });
                } else {
                    unassigned.push(note);
                }
            });

            // Renderizar notas por persona
            let html = '';

            // En modo asignaci√≥n, mostrar notas sin asignar primero
            if (assignmentMode && unassigned.length > 0) {
                html += `
                    <div class="person-group">
                        <div class="person-group-header" style="color: #888; border-color: #444;">
                            <span>‚ùì Sin Asignar</span>
                            <span style="font-size: 0.9rem;">(${unassigned.length})</span>
                        </div>
                        ${unassigned.map(note => renderNoteCard(note)).join('')}
                    </div>
                `;
            }

            // Notas asignadas por persona
            people.forEach(person => {
                if (groupedByPerson[person] && groupedByPerson[person].length > 0) {
                    const personNotes = groupedByPerson[person];
                    const personColor = personColors[person] || '#00ff88';

                    html += `
                        <div class="person-group">
                            <div class="person-group-header" style="color: ${personColor} !important; border-color: ${personColor} !important; background: rgba(${hexToRgb(personColor)}, 0.1);">
                                <span style="color: ${personColor} !important; font-weight: bold;">üë§ ${person}</span>
                                <span style="font-size: 0.9rem; color: #888;">(${personNotes.length})</span>
                            </div>
                            ${personNotes.map(note => renderNoteCard(note)).join('')}
                        </div>
                    `;
                }
            });

            // Notas sin asignar al final (si NO estamos en modo asignaci√≥n)
            if (!assignmentMode && unassigned.length > 0) {
                html += `
                    <div class="person-group">
                        <div class="person-group-header" style="color: #888; border-color: #444;">
                            <span>‚ùì Sin Asignar</span>
                            <span style="font-size: 0.9rem;">(${unassigned.length})</span>
                        </div>
                        ${unassigned.map(note => renderNoteCard(note)).join('')}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Renderizar una tarjeta de nota individual (reutilizable)
        function renderNoteCard(note) {
            const hasAssignment = note.assignedTo && note.assignedTo.length > 0;
            const showAssignmentUI = assignmentMode && (!hasAssignment || editingAssignments.has(note.id));

            return `
                <div class="note-card ${note.priority ? 'priority-' + note.priority : ''}" style="position: relative;">
                    ${editingNoteId === note.id ? `
                        <input type="text"
                               class="note-edit-input"
                               id="edit-input-${note.id}"
                               value="${escapeHtml(note.text)}"
                               onkeypress="if(event.key==='Enter') saveEditNote(${note.id}, event); else if(event.key==='Escape') cancelEditNote(event);"
                               autofocus>
                        <div class="edit-actions">
                            <button class="save-btn" onclick="saveEditNote(${note.id}, event)">‚úì Guardar</button>
                            <button class="cancel-btn" onclick="cancelEditNote(event)">‚úï Cancelar</button>
                        </div>
                    ` : `
                        <div class="note-card-content">
                            <div class="note-card-text" onclick="startEditNote(${note.id}, event)" style="cursor: pointer;">${escapeHtml(note.text)}</div>
                            <div class="note-card-badges">
                                <span class="note-category-badge">${getCategoryEmoji(note.category)} ${note.category}</span>
                                ${note.tags && note.tags.length > 0 ? `
                                    <div class="note-tags-container">
                                        ${note.tags.map(tag => `<span class="note-tag">${tag}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${showAssignmentUI ? `
                            <div class="assignment-section" style="margin-top: 12px; padding: 12px; background: #16213e; border-radius: 6px;">
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">üë• ASIGNAR A:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${people.map(person => `
                                            <label class="person-checkbox ${note.assignedTo && note.assignedTo.includes(person) ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="togglePersonInCard(${note.id}, '${person}', event)">
                                                <input type="checkbox"
                                                       value="${person}"
                                                       ${note.assignedTo && note.assignedTo.includes(person) ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${person}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">üìä DIFICULTAD:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${difficulties.map(diff => `
                                            <label class="person-checkbox ${note.difficulty === diff.toLowerCase() ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="selectDifficultyInCard(${note.id}, '${diff.toLowerCase()}', event)">
                                                <input type="radio"
                                                       name="difficulty-card-${note.id}"
                                                       value="${diff.toLowerCase()}"
                                                       ${note.difficulty === diff.toLowerCase() ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${diff}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">‚ö° PRIORIDAD:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${priorities.map(prio => `
                                            <label class="person-checkbox ${note.priority === prio.toLowerCase() ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="selectPriorityInCard(${note.id}, '${prio.toLowerCase()}', event)">
                                                <input type="radio"
                                                       name="priority-card-${note.id}"
                                                       value="${prio.toLowerCase()}"
                                                       ${note.priority === prio.toLowerCase() ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${prio}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <button class="save-btn" onclick="saveAssignmentInCard(${note.id}, event)" style="width: 100%;">‚úì Guardar Asignaci√≥n</button>
                            </div>
                        ` : note.assignedTo && note.assignedTo.length > 0 ? `
                            <div class="assigned-people-container" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">üë§ ${person}</span>`).join('')}
                                ${assignmentMode ? `<button class="edit-btn" onclick="editAssignmentInCard(${note.id}, event)" style="padding: 4px 8px; font-size: 0.8rem;">‚úé Editar</button>` : ''}
                            </div>
                        ` : ''}
                        <div class="note-card-meta">
                            <span>${formatTime(note.timestamp)}</span>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span class="work-status-badge"
                                      onclick="toggleWorkStatusSelector(${note.id}, event)"
                                      style="background: ${workStatusColors[note.workStatus || 'not_started']};">
                                    ${workStatusLabels[note.workStatus || 'not_started']}
                                </span>
                                <span class="priority-badge ${note.priority ? 'priority-' + note.priority : ''}"
                                      onclick="togglePrioritySelector(${note.id}, event)"
                                      style="${!note.priority ? 'background: #16213e; color: #888;' : ''}">
                                    ${note.priority ? note.priority.toUpperCase() : '‚ö° Prioridad'}
                                </span>
                                <button class="edit-btn" onclick="startEditNote(${note.id}, event)">‚úé</button>
                                <button class="delete-btn" onclick="deleteNote(${note.id}, event)">‚úï</button>
                            </div>
                        </div>
                        <div class="work-status-selector" id="work-status-selector-${note.id}">
                            <button class="work-status-option" style="background: ${workStatusColors.not_started};" onclick="setWorkStatus(${note.id}, 'not_started', event)">‚≠ï NO EMPEZADO</button>
                            <button class="work-status-option" style="background: ${workStatusColors.wip};" onclick="setWorkStatus(${note.id}, 'wip', event)">üîÑ WIP</button>
                            <button class="work-status-option" style="background: ${workStatusColors.awaiting_review};" onclick="setWorkStatus(${note.id}, 'awaiting_review', event)">‚è≥ ESPERANDO REVISI√ìN</button>
                            <button class="work-status-option" style="background: ${workStatusColors.accepted};" onclick="setWorkStatus(${note.id}, 'accepted', event)">‚úÖ ACEPTADO</button>
                            <button class="work-status-option" style="background: ${workStatusColors.rejected};" onclick="setWorkStatus(${note.id}, 'rejected', event)">‚ùå RECHAZADO</button>
                        </div>
                        <div class="priority-selector" id="priority-selector-${note.id}">
                            <button class="priority-option priority-critical" onclick="setPriority(${note.id}, 'critical', event)">üî¥ CR√çTICA</button>
                            <button class="priority-option priority-high" onclick="setPriority(${note.id}, 'high', event)">üü† ALTA</button>
                            <button class="priority-option priority-medium" onclick="setPriority(${note.id}, 'medium', event)">üü° MEDIA</button>
                            <button class="priority-option priority-low" onclick="setPriority(${note.id}, 'low', event)">üîµ BAJA</button>
                        </div>
                    `}
                </div>
            `;
        }

        // Agregar al historial
        function addToHistory(action, description) {
            history.unshift({
                timestamp: new Date().toISOString(),
                action: action,
                description: description
            });

            if (history.length > 100) {
                history = history.slice(0, 100);
            }

            saveToLocalStorage();
            renderHistory();
        }

        // Renderizar historial
        function renderHistory() {
            const container = document.getElementById('historyContent');

            if (history.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay historial a√∫n</div>';
                return;
            }

            container.innerHTML = history.map(item => `
                <div class="history-item">
                    <span class="time">${formatTime(item.timestamp)}</span>
                    <span class="action">${escapeHtml(item.description)}</span>
                </div>
            `).join('');
        }

        // Toggle historial
        function toggleHistory() {
            document.getElementById('historyPanel').classList.toggle('active');
        }

        // Toggle entre vista por categor√≠a y por persona
        function toggleView(mode) {
            assignmentViewMode = mode;

            // Actualizar botones
            const categoryBtn = document.getElementById('viewByCategoryBtn');
            const personBtn = document.getElementById('viewByPersonBtn');

            if (mode === 'category') {
                categoryBtn.style.background = '#00ff88';
                categoryBtn.style.color = '#0a0a0f';
                categoryBtn.style.fontWeight = 'bold';
                personBtn.style.background = 'transparent';
                personBtn.style.color = '#888';
                personBtn.style.fontWeight = 'normal';
            } else {
                personBtn.style.background = '#00ff88';
                personBtn.style.color = '#0a0a0f';
                personBtn.style.fontWeight = 'bold';
                categoryBtn.style.background = 'transparent';
                categoryBtn.style.color = '#888';
                categoryBtn.style.fontWeight = 'normal';
            }

            renderNotes();
        }

        // Exportar notas
        function exportNotes() {
            if (notes.length === 0) {
                alert('No hay notas para exportar');
                return;
            }

            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                notes: notes,
                history: history
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const date = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `eggscape-notes-${date}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addToHistory('export', `Exportadas ${notes.length} notas`);
            console.log('‚úÖ Notas exportadas');
        }

        // Exportar notas por persona
        function exportByPerson() {
            if (notes.length === 0) {
                alert('No hay notas para exportar');
                return;
            }

            // Agrupar notas por persona
            const tasksByPerson = {};
            const unassignedTasks = [];

            notes.forEach(note => {
                if (note.assignedTo && note.assignedTo.length > 0) {
                    note.assignedTo.forEach(person => {
                        if (!tasksByPerson[person]) {
                            tasksByPerson[person] = [];
                        }
                        tasksByPerson[person].push(note);
                    });
                } else {
                    unassignedTasks.push(note);
                }
            });

            // Generar reporte en texto
            const date = new Date().toLocaleDateString('es-AR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            let report = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n`;
            report += `‚ïë     EGGSCAPE - TAREAS POR PERSONA - ${date}     ‚ïë\n`;
            report += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n`;

            // Ordenar personas alfab√©ticamente
            const sortedPeople = Object.keys(tasksByPerson).sort();

            sortedPeople.forEach(person => {
                const tasks = tasksByPerson[person];
                report += `\n${'‚ïê'.repeat(70)}\n`;
                report += `üë§ ${person} - ${tasks.length} tarea${tasks.length !== 1 ? 's' : ''}\n`;
                report += `${'‚ïê'.repeat(70)}\n\n`;

                // Agrupar por prioridad
                const byPriority = {
                    'critical': [],
                    'high': [],
                    'medium': [],
                    'low': [],
                    'none': []
                };

                tasks.forEach(task => {
                    const priority = task.priority || 'none';
                    byPriority[priority].push(task);
                });

                // Mostrar por prioridad
                const priorityOrder = ['critical', 'high', 'medium', 'low', 'none'];
                const priorityLabels = {
                    'critical': 'üî¥ CR√çTICA',
                    'high': 'üü† ALTA',
                    'medium': 'üü° MEDIA',
                    'low': 'üîµ BAJA',
                    'none': '‚ö™ SIN PRIORIDAD'
                };

                priorityOrder.forEach(priority => {
                    const priorityTasks = byPriority[priority];
                    if (priorityTasks.length > 0) {
                        report += `  ${priorityLabels[priority]}:\n`;
                        report += `  ${'-'.repeat(65)}\n`;

                        priorityTasks.forEach((task, index) => {
                            report += `  ${index + 1}. ${task.text}\n`;

                            // Informaci√≥n adicional
                            const details = [];
                            if (task.category) details.push(`Categor√≠a: ${task.category}`);
                            if (task.difficulty) details.push(`Dificultad: ${task.difficulty.toUpperCase()}`);
                            if (task.tags && task.tags.length > 0) details.push(`Tags: ${task.tags.join(', ')}`);

                            if (details.length > 0) {
                                report += `     ${details.join(' | ')}\n`;
                            }
                            report += `\n`;
                        });
                    }
                });
            });

            // Tareas sin asignar
            if (unassignedTasks.length > 0) {
                report += `\n${'‚ïê'.repeat(70)}\n`;
                report += `üìã TAREAS SIN ASIGNAR - ${unassignedTasks.length} tarea${unassignedTasks.length !== 1 ? 's' : ''}\n`;
                report += `${'‚ïê'.repeat(70)}\n\n`;

                unassignedTasks.forEach((task, index) => {
                    report += `${index + 1}. ${task.text}\n`;

                    const details = [];
                    if (task.category) details.push(`Categor√≠a: ${task.category}`);
                    if (task.difficulty) details.push(`Dificultad: ${task.difficulty.toUpperCase()}`);
                    if (task.priority) details.push(`Prioridad: ${task.priority.toUpperCase()}`);
                    if (task.tags && task.tags.length > 0) details.push(`Tags: ${task.tags.join(', ')}`);

                    if (details.length > 0) {
                        report += `   ${details.join(' | ')}\n`;
                    }
                    report += `\n`;
                });
            }

            // Resumen
            report += `\n${'‚ïê'.repeat(70)}\n`;
            report += `üìä RESUMEN\n`;
            report += `${'‚ïê'.repeat(70)}\n`;
            report += `Total de tareas: ${notes.length}\n`;
            report += `Tareas asignadas: ${notes.filter(n => n.assignedTo && n.assignedTo.length > 0).length}\n`;
            report += `Tareas sin asignar: ${unassignedTasks.length}\n`;
            report += `Personas con tareas: ${sortedPeople.length}\n`;

            // Descargar archivo
            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const dateStr = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `eggscape-tareas-por-persona-${dateStr}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addToHistory('export', `Exportadas tareas por persona (${sortedPeople.length} personas)`);
            console.log('‚úÖ Tareas por persona exportadas');
        }

        // Importar notas
        function importNotes(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validar estructura
                    if (!data.notes || !Array.isArray(data.notes)) {
                        throw new Error('Formato de archivo inv√°lido');
                    }

                    const importCount = data.notes.length;

                    if (!confirm(`¬øImportar ${importCount} nota${importCount !== 1 ? 's' : ''}?\n\nEsto se agregar√° a tus notas existentes.`)) {
                        event.target.value = '';
                        return;
                    }

                    // Agregar notas importadas
                    data.notes.forEach(note => {
                        // Asignar nuevo ID para evitar conflictos
                        note.id = Date.now() + Math.random();

                        // Asegurar que tenga todos los campos necesarios
                        if (!note.assignedTo) note.assignedTo = [];
                        if (!note.difficulty) note.difficulty = null;
                        if (!note.priority) note.priority = null;
                        if (!note.reviewStatus) note.reviewStatus = null;
                        if (!note.rejectionComment) note.rejectionComment = '';
                        if (!note.workStatus) note.workStatus = 'not_started';
                        if (!note.buildReviewDate) note.buildReviewDate = note.timestamp || new Date().toISOString();

                        notes.push(note);
                        addTerminalLine(note.text, note.id);
                        if (note.aiProcessed) {
                            updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                        }
                    });

                    // Importar historial si existe
                    if (data.history && Array.isArray(data.history)) {
                        data.history.forEach(item => history.push(item));
                    }

                    saveToLocalStorage();
                    renderNotes();
                    renderHistory();

                    addToHistory('import', `Importadas ${importCount} notas`);
                    alert(`‚úÖ Importadas ${importCount} notas correctamente!`);
                    console.log('‚úÖ Notas importadas');

                } catch (error) {
                    console.error('‚ùå Error importando:', error);
                    alert('‚ùå Error al importar el archivo.\n\nAseg√∫rate de que sea un archivo v√°lido exportado desde esta aplicaci√≥n.');
                }

                // Limpiar input
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Guardar/Cargar desde servidor
        async function saveToLocalStorage() {
            // Guardar localmente tambi√©n como backup
            localStorage.setItem('eggscape_notes', JSON.stringify(notes));
            localStorage.setItem('eggscape_history', JSON.stringify(history));

            // Guardar en Supabase
            try {
                console.log('üíæ [SAVE] Intentando guardar en Supabase...', notes.length, 'notas');
                console.log('üíæ [SAVE] supabaseClient:', supabaseClient);
                console.log('üíæ [SAVE] Datos a guardar:', { notesCount: notes.length, historyCount: history.length });

                const { data, error } = await supabaseClient
                    .from('app_data')
                    .update({
                        data: { notes, history },
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', 1);

                console.log('üíæ [SAVE] Respuesta de Supabase - data:', data);
                console.log('üíæ [SAVE] Respuesta de Supabase - error:', error);

                if (error) {
                    console.error('‚ùå [SAVE] Error guardando en Supabase:', error);
                    console.error('‚ùå [SAVE] Error details:', JSON.stringify(error, null, 2));
                    showNotification('‚ö†Ô∏è Error guardando en Supabase. Datos guardados solo localmente.', 'error');
                } else {
                    console.log('‚úÖ [SAVE] Guardado exitoso en Supabase');
                }
            } catch (error) {
                console.error('‚ùå [SAVE] Error de red guardando en Supabase:', error);
                console.error('‚ùå [SAVE] Error stack:', error.stack);
                showNotification('‚ö†Ô∏è Error de conexi√≥n con Supabase. Datos guardados solo localmente.', 'error');
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'error' ? '#ff4444' : '#00ff88'};
                color: ${type === 'error' ? '#fff' : '#000'};
                padding: 15px 20px;
                border-radius: 5px;
                font-family: 'Courier New', monospace;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
        }

        async function loadFromLocalStorage() {
            try {
                // Cargar desde Supabase
                console.log('üì• [LOAD] Cargando datos desde Supabase...');
                console.log('üì• [LOAD] supabaseClient:', supabaseClient);

                const { data, error } = await supabaseClient
                    .from('app_data')
                    .select('data')
                    .eq('id', 1)
                    .single();

                console.log('üì• [LOAD] Respuesta de Supabase - data:', data);
                console.log('üì• [LOAD] Respuesta de Supabase - error:', error);

                if (error) {
                    console.error('‚ùå [LOAD] Error cargando desde Supabase:', error);
                    console.error('‚ùå [LOAD] Error details:', JSON.stringify(error, null, 2));
                    // Fallback a localStorage
                    console.log('‚ö†Ô∏è [LOAD] Usando localStorage como fallback');
                    const savedNotes = localStorage.getItem('eggscape_notes');
                    const savedHistory = localStorage.getItem('eggscape_history');
                    console.log('‚ö†Ô∏è [LOAD] localStorage notes:', savedNotes ? 'encontradas' : 'no encontradas');
                    console.log('‚ö†Ô∏è [LOAD] localStorage history:', savedHistory ? 'encontrado' : 'no encontrado');
                    if (savedNotes) notes = JSON.parse(savedNotes);
                    if (savedHistory) history = JSON.parse(savedHistory);
                } else {
                    console.log('üì• [LOAD] data.data:', data.data);
                    notes = data.data.notes || [];
                    history = data.data.history || [];
                    console.log('‚úÖ [LOAD] Notas cargadas desde Supabase:', notes.length);
                }
            } catch (error) {
                // Fallback a localStorage
                console.error('‚ö†Ô∏è [LOAD] Exception cargando desde Supabase, usando localStorage:', error);
                console.error('‚ö†Ô∏è [LOAD] Error stack:', error.stack);
                const savedNotes = localStorage.getItem('eggscape_notes');
                const savedHistory = localStorage.getItem('eggscape_history');
                if (savedNotes) notes = JSON.parse(savedNotes);
                if (savedHistory) history = JSON.parse(savedHistory);
            }

            // Asegurar que todas las notas tengan workStatus (backward compatibility)
            notes.forEach(note => {
                if (!note.workStatus) note.workStatus = 'not_started';
                if (!note.buildReviewDate) note.buildReviewDate = note.timestamp || new Date().toISOString();
            });

            // Renderizar notas cargadas
            notes.forEach(note => {
                addTerminalLine(note.text, note.id);
                if (note.aiProcessed) {
                    updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                }
            });
        }

        // Utilidades
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' });
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 255, 136';
        }

        function getPersonColorStyle(person) {
            const color = personColors[person] || '#ff88ff';
            return `background: ${color}; color: #000; border-color: ${color}; font-weight: bold;`;
        }

        function getCategoryEmoji(category) {
            const emojis = {
                'Bug': 'üêõ', 'Feature': '‚ú®', 'Performance': '‚ö°', 'UI': 'üé®',
                'Sound': 'üîä', 'Gameplay': 'üéÆ', 'Level Design': 'üó∫Ô∏è',
                'Backend': '‚öôÔ∏è', 'Tools': 'üîß', 'Other': 'üìù'
            };
            return emojis[category] || 'üìù';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Inicializar
        init();
    </script>
</body>
</html>
