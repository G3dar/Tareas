<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eggscape Build Notes - 2025-10-13</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: #1a1a2e;
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #00ff88;
            font-size: 1.5rem;
        }

        .header .date {
            color: #888;
            font-size: 0.9rem;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .terminal-section {
            flex: 1;
            display: none; /* Ocultado */
            flex-direction: column;
            background: #0f0f1a;
            border-right: 2px solid #1a1a2e;
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-size: 0.95rem;
        }

        .terminal-line {
            margin-bottom: 15px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            animation: fadeIn 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .terminal-line-main {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .terminal-line-text {
            flex: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .terminal-line .prompt {
            color: #00ff88;
            margin-right: 10px;
        }

        .terminal-line .text {
            color: #eee;
        }

        .terminal-line .ai-processing {
            color: #ffa500;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        .terminal-line .ai-result {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .terminal-category-badge {
            background: #16213e;
            color: #00ff88;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .terminal-tag {
            background: #0f3a2e;
            color: #00ff88;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #00ff8844;
        }

        .assignment-mode-toggle {
            background: #2e1a3a;
            color: #ff88ff;
            border: 2px solid #ff88ff44;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .assignment-mode-toggle.active {
            background: #4a2a5a;
            border-color: #ff88ff;
        }

        .assignment-mode-toggle:hover {
            background: #3a2050;
        }

        .assignment-section {
            margin-top: 8px;
            padding: 8px;
            background: #0f0f1a;
            border-radius: 4px;
            border: 1px solid #ff88ff44;
        }

        .assignment-people {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .person-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #1a1a2e;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            border: 1px solid #ff88ff44;
        }

        .person-checkbox:hover {
            background: #242444;
        }

        .person-checkbox input[type="checkbox"],
        .person-checkbox input[type="radio"] {
            cursor: pointer;
            margin: 0;
        }

        .person-checkbox.selected {
            background: #2e1a3a;
            border-color: #ff88ff;
        }

        .assigned-person {
            background: #2e1a3a;
            color: #ff88ff;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #ff88ff88;
            white-space: nowrap;
        }

        .assigned-people-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .terminal-input-container {
            background: #1a1a2e;
            padding: 20px;
            border-top: 2px solid #00ff88;
        }

        .terminal-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-input-wrapper .prompt {
            color: #00ff88;
            font-size: 1.2rem;
            font-weight: bold;
        }

        #terminalInput {
            flex: 1;
            background: #0f0f1a;
            border: 2px solid #16213e;
            color: #00ff88;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            border-radius: 4px;
        }

        #terminalInput:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        #buildReviewInput {
            flex: 1;
            background: #000000;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 18px 24px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: 500;
            border-radius: 8px;
            width: 100%;
            letter-spacing: 0.5px;
        }

        #buildReviewInput:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            background: #0a0a0a;
        }

        #buildReviewInput::placeholder {
            color: #00ff8866;
            font-style: italic;
        }

        .notes-section {
            width: 100%; /* Pantalla completa */
            background: #0f0f1a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .notes-header {
            background: #1a1a2e;
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notes-header h2 {
            color: #00ff88;
            font-size: 1.2rem;
        }

        .notes-count {
            color: #888;
            font-size: 0.9rem;
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tag-group {
            margin-bottom: 25px;
        }

        .tag-group-header {
            color: #00ff88;
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #16213e;
            display: flex;
            justify-content: space-between;
        }

        .person-group {
            margin-bottom: 30px;
        }

        .person-group-header {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 15px;
            padding: 12px;
            padding-bottom: 10px;
            border-bottom: 3px solid;
            border-radius: 4px 4px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-badge {
            background: #16213e;
            color: #00ff88;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .note-card {
            background: #1a1a2e;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            transition: all 0.2s;
        }

        .note-card:hover {
            background: #242444;
        }

        .note-card.priority-critical {
            border-left-color: #ff0040;
            background: #2a1a20;
        }

        .note-card.priority-high {
            border-left-color: #ff6600;
            background: #2a2010;
        }

        .note-card.priority-medium {
            border-left-color: #ffcc00;
            background: #2a2610;
        }

        .note-card.priority-low {
            border-left-color: #00aaff;
            background: #1a2030;
        }

        .note-card-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 8px;
        }

        .note-card-text {
            color: #eee;
            font-size: 0.9rem;
            word-break: break-word;
            flex: 1;
        }

        .note-card-text:hover {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
        }

        .note-card-badges {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
            flex-shrink: 0;
        }

        .note-category-badge {
            background: #16213e;
            color: #00ff88;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .note-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: flex-end;
            max-width: 200px;
        }

        .note-tag {
            background: #0f3a2e;
            color: #00ff88;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            border: 1px solid #00ff8844;
            white-space: nowrap;
        }

        .note-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            font-size: 0.75rem;
            color: #888;
            flex-wrap: wrap;
        }

        .priority-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .priority-badge:hover {
            transform: scale(1.1);
        }

        .priority-critical {
            background: #ff0040;
            color: white;
        }

        .priority-high {
            background: #ff6600;
            color: white;
        }

        .priority-medium {
            background: #ffcc00;
            color: #1a1a2e;
        }

        .priority-low {
            background: #00aaff;
            color: white;
        }

        .priority-selector {
            position: absolute;
            background: #1a1a2e;
            border: 2px solid #00ff88;
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .priority-selector.active {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .priority-option {
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            border: none;
            font-family: 'Courier New', monospace;
        }

        .priority-option:hover {
            transform: scale(1.05);
        }

        .work-status-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .work-status-badge:hover {
            transform: scale(1.1);
        }

        .work-status-selector {
            position: absolute;
            background: #1a1a2e;
            border: 2px solid #00ff88;
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .work-status-selector.active {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .work-status-option {
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            border: none;
            font-family: 'Courier New', monospace;
            color: white;
        }

        .work-status-option:hover {
            transform: scale(1.05);
        }

        .delete-btn, .edit-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .edit-btn {
            background: #0088ff;
        }

        .delete-btn:hover {
            background: #ff6680;
        }

        .edit-btn:hover {
            background: #00aaff;
        }

        .note-edit-input {
            width: 100%;
            background: #0f0f1a;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .note-edit-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .edit-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }

        .save-btn, .cancel-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .save-btn {
            background: #00ff88;
            color: #0a0a0f;
            font-weight: bold;
        }

        .save-btn:hover {
            background: #00ffaa;
        }

        .cancel-btn {
            background: #666;
            color: white;
        }

        .cancel-btn:hover {
            background: #888;
        }

        .history-toggle {
            background: #16213e;
            color: #00ff88;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .history-toggle:hover {
            background: #242444;
        }

        .history-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: #1a1a2e;
            border-left: 2px solid #00ff88;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .history-panel.active {
            right: 0;
        }

        .history-panel-header {
            padding: 15px 20px;
            background: #0f0f1a;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-panel-header h3 {
            color: #00ff88;
        }

        .close-btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .day-filter-btn {
            padding: 6px 14px;
            background: #16213e;
            color: #888;
            border: 1px solid #00ff8844;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .day-filter-btn.active {
            background: #00ff88;
            color: #0a0a0f;
            font-weight: bold;
        }

        .day-filter-btn:hover {
            background: #1a2e3e;
        }

        .history-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .history-item {
            background: #0f0f1a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .history-item .time {
            color: #00ff88;
            margin-right: 10px;
        }

        .history-item .action {
            color: #888;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0f;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Review Mode Styles */
        .review-panel {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            background: #0a0a0f;
            z-index: 1001;
            display: none;
            flex-direction: column;
        }

        .review-panel.active {
            display: flex;
        }

        .main-container.review-active {
            display: none;
        }

        .review-header {
            padding: 15px 20px;
            background: #0f0f1a;
            border-bottom: 2px solid #ffaa00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-header h3 {
            color: #ffaa00;
        }

        .review-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .review-toggle {
            background: #3a2010;
            color: #ffaa00;
            border: 2px solid #ffaa0044;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .review-toggle.active {
            background: #5a3010;
            border-color: #ffaa00;
        }

        .review-content {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .review-person-section {
            margin-bottom: 50px;
            background: #0f0f1a;
            border-radius: 8px;
            padding: 25px;
            border: 2px solid #ffaa0044;
        }

        .review-person-title {
            color: #ffaa00;
            font-weight: bold;
            font-size: 1.8rem;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #ffaa00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-person-count {
            font-size: 1.2rem;
            color: #888;
            font-weight: normal;
        }

        .review-nav {
            background: #0f0f1a;
            padding: 15px 40px;
            border-bottom: 2px solid #ffaa0044;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .review-nav-link {
            background: #1a1a2e;
            color: #ffaa00;
            padding: 8px 16px;
            border-radius: 4px;
            border: 2px solid #ffaa0044;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.2s;
        }

        .review-nav-link:hover {
            background: #3a2010;
            border-color: #ffaa00;
            transform: translateY(-2px);
        }

        .review-nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding-left: 20px;
            margin-left: 20px;
            border-left: 2px solid #ffaa0044;
        }

        .review-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ffaa00;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
        }

        .review-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .review-item {
            background: #1a1a2e;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 6px;
            border-left: 4px solid #ffaa00;
        }

        .review-item.accepted {
            border-left-color: #00ff88;
            background: #0f1a14;
        }

        .review-item.rejected {
            border-left-color: #e94560;
            background: #1a0f14;
        }

        .review-item-text {
            color: #eee;
            font-size: 1.05rem;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .review-item-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 0.75rem;
        }

        .review-meta-badge {
            background: #16213e;
            color: #00ff88;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
        }

        .review-filter-container {
            padding: 15px 40px;
            background: #0f0f1a;
            border-bottom: 2px solid #ffaa0044;
        }

        .review-filter-input {
            width: 100%;
            background: #1a1a2e;
            border: 2px solid #ffaa0044;
            color: #ffaa00;
            padding: 12px 15px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .review-filter-input:focus {
            outline: none;
            border-color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .review-filter-input::placeholder {
            color: #888;
        }

        .review-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .review-btn-accept, .review-btn-reject {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        .review-btn-accept {
            background: #00ff88;
            color: #0a0a0f;
        }

        .review-btn-accept:hover {
            background: #00ffaa;
            transform: scale(1.05);
        }

        .review-btn-reject {
            background: #e94560;
            color: white;
        }

        .review-btn-reject:hover {
            background: #ff6680;
            transform: scale(1.05);
        }

        .review-comment-input {
            width: 100%;
            background: #0f0f1a;
            border: 2px solid #e94560;
            color: #eee;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border-radius: 4px;
            margin-top: 10px;
        }

        .review-comment-input:focus {
            outline: none;
            border-color: #ff6680;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
        }

        .review-comment-display {
            margin-top: 10px;
            padding: 8px;
            background: #1a0f14;
            border-left: 3px solid #e94560;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #ff6680;
        }

        .review-status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .review-status-accepted {
            background: #00ff88;
            color: #0a0a0f;
        }

        .review-status-rejected {
            background: #e94560;
            color: white;
        }

        @media (max-width: 1024px) {
            .notes-section {
                width: 100%; /* Pantalla completa en todas las resoluciones */
            }
        }

        @media (max-width: 768px) {
            /* Header adaptado para mobile */
            .header {
                flex-direction: column;
                gap: 10px;
                padding: 12px;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.2rem;
                text-align: center;
                margin-bottom: 8px;
            }

            .header > div {
                flex-direction: column;
                gap: 8px !important;
                width: 100%;
            }

            .header button {
                width: 100%;
                padding: 10px !important;
                font-size: 0.9rem !important;
            }

            .date {
                text-align: center;
                width: 100%;
            }

            /* Main container en columna */
            .main-container {
                flex-direction: column;
                height: auto;
            }

            .terminal-section {
                width: 100%;
                height: 50vh;
                min-height: 300px;
                border-right: none;
                display: none; /* Ocultado en mobile también */
            }

            .terminal-input {
                font-size: 0.9rem;
                padding: 12px;
            }

            .terminal-output {
                font-size: 0.85rem;
                padding: 15px;
            }

            .notes-section {
                width: 100%;
                height: auto;
                min-height: 50vh;
                border-right: none;
                border-top: 2px solid #1a1a2e;
            }

            .notes-header {
                padding: 12px;
                flex-wrap: wrap;
                gap: 8px;
            }

            .notes-header button {
                font-size: 0.8rem;
                padding: 6px 10px;
            }

            /* Historial mobile */
            .history-panel {
                width: 100%;
                left: 0;
            }

            /* Review mode mobile */
            .review-panel {
                padding: 0;
            }

            .review-header {
                flex-direction: column;
                gap: 10px;
                padding: 12px;
            }

            .review-controls {
                width: 100%;
                flex-direction: column;
                gap: 8px;
            }

            .review-controls button {
                width: 100%;
            }

            .review-filter-container {
                padding: 12px;
            }

            .review-filter-input {
                font-size: 0.9rem;
            }

            #reviewPersonFilters {
                gap: 6px !important;
            }

            #reviewPersonFilters button {
                font-size: 0.75rem !important;
                padding: 6px 8px !important;
            }

            .review-content {
                padding: 12px;
            }

            .review-item {
                padding: 12px;
                font-size: 0.9rem;
            }

            .review-item-meta {
                flex-wrap: wrap;
                gap: 6px;
            }

            .review-meta-badge {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            /* Assignment mode mobile */
            .assignment-section {
                padding: 10px;
            }

            .assignment-people {
                gap: 6px;
            }

            .person-checkbox {
                font-size: 0.75rem;
                padding: 6px 10px;
            }

            .assigned-person {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            /* Note cards mobile */
            .note-card {
                padding: 12px;
                font-size: 0.9rem;
            }

            .note-card-text {
                font-size: 0.9rem;
                line-height: 1.4;
            }

            .note-category-badge,
            .note-tag {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            .note-card-meta {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }

            .note-card-meta > div {
                width: 100%;
                justify-content: flex-start;
            }

            .priority-badge,
            .work-status-badge {
                font-size: 0.75rem;
                padding: 4px 10px;
            }

            .edit-btn,
            .delete-btn,
            .save-btn,
            .cancel-btn {
                font-size: 0.8rem;
                padding: 6px 10px;
            }

            /* Tag groups mobile */
            .tag-group-header {
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            /* Terminal line mobile */
            .terminal-line {
                font-size: 0.85rem;
            }

            .terminal-category-badge,
            .terminal-tag {
                font-size: 0.7rem;
                padding: 3px 6px;
            }

            /* Work status selector mobile */
            .work-status-selector,
            .priority-selector {
                width: 100%;
                left: 0 !important;
                right: 0 !important;
            }

            .work-status-option,
            .priority-option {
                font-size: 0.8rem;
                padding: 10px;
            }

            /* Review person section mobile */
            .review-person-section {
                margin-bottom: 20px;
            }

            .review-person-title {
                font-size: 1rem;
                padding: 10px;
            }

            /* Hide some elements on very small screens */
            .date {
                font-size: 0.85rem;
            }
        }

        /* Landscape mobile adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .terminal-section {
                height: 40vh;
                display: none; /* Ocultado en landscape también */
            }

            .notes-section {
                min-height: 100vh; /* Pantalla completa en landscape */
            }
        }

        /* Very small mobile devices */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1rem;
            }

            .terminal-output {
                font-size: 0.8rem;
                padding: 10px;
            }

            .terminal-input {
                font-size: 0.85rem;
                padding: 10px;
            }

            .note-card {
                padding: 10px;
            }

            .review-item {
                padding: 10px;
            }

            #reviewPersonFilters {
                font-size: 0.7rem;
            }

            #reviewPersonFilters button {
                font-size: 0.7rem !important;
                padding: 5px 6px !important;
            }

            .assignment-people label {
                font-size: 0.7rem;
                padding: 5px 8px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div class="header">
        <h1>🥚 Eggscape Build Notes</h1>
        <div style="display: flex; gap: 15px; align-items: center;">
            <div class="date">2025-10-13</div>
            <button class="assignment-mode-toggle" id="buildReviewModeBtn" onclick="toggleBuildReviewMode()" style="background: #1a3a2e; color: #00ff88; border-color: #00ff8844;">
                📝 BUILD REVIEW
            </button>
            <button class="assignment-mode-toggle" id="assignmentModeBtn" onclick="toggleAssignmentMode()">
                👥 MODO ASIGNACIÓN
            </button>
            <button class="assignment-mode-toggle" id="reviewModeBtn" onclick="toggleReviewMode()" style="background: #3a2010; color: #ffaa00; border-color: #ffaa0044;">
                ✓ MODO REVISIÓN
            </button>
            <button class="history-toggle" onclick="exportNotes()" style="padding: 6px 12px; font-size: 0.85rem;">📥 Exportar</button>
            <button class="history-toggle" onclick="exportByPerson()" style="padding: 6px 12px; font-size: 0.85rem;">👥 Exportar por Persona</button>
            <button class="history-toggle" onclick="document.getElementById('importFile').click()" style="padding: 6px 12px; font-size: 0.85rem;">📤 Importar</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importNotes(event)">
            <button class="history-toggle" onclick="toggleHistory()">📜 Historial</button>
        </div>
    </div>

    <div class="main-container">
        <div class="terminal-section">
            <div id="assignmentFilterBar" style="display: none; padding: 10px 15px; background: #0f0f1a; border-bottom: 1px solid #1a1a2e;">
                <input
                    type="text"
                    id="assignmentFilterInput"
                    placeholder="🔍 Filtrar por palabra clave..."
                    oninput="filterAssignmentNotes()"
                    style="width: 100%; padding: 8px 12px; background: #16213e; border: 1px solid #00ff8844; border-radius: 4px; color: #eee; font-size: 0.9rem; margin-bottom: 10px;"
                >
                <div id="assignmentPersonFilters" style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <!-- Los filtros se generarán dinámicamente aquí -->
                </div>
            </div>
            <div class="terminal-output" id="terminalOutput">
                <div style="color: #00ff88; margin-bottom: 20px; font-size: 1.1rem;">
                    💬 Escribe tus notas y presiona Enter. La AI las organizará automáticamente.
                </div>
            </div>
            <div class="terminal-input-container">
                <div class="terminal-input-wrapper">
                    <span class="prompt">></span>
                    <input
                        type="text"
                        id="terminalInput"
                        placeholder="Escribe aquí tu nota..."
                        autofocus
                    >
                </div>
            </div>
        </div>

        <div class="notes-section">
            <div class="notes-header">
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <h2>📋 Notas Organizadas</h2>
                    <span class="notes-count" id="notesCount">0 notas</span>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                    <div style="display: flex; gap: 5px; background: #16213e; padding: 4px; border-radius: 4px;">
                        <button class="view-toggle-btn active" id="viewByCategoryBtn" onclick="toggleView('category')" style="padding: 6px 12px; font-size: 0.8rem; border: none; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace; transition: all 0.2s; background: #00ff88; color: #0a0a0f; font-weight: bold;">
                            📂 Por Categoría
                        </button>
                        <button class="view-toggle-btn" id="viewByPersonBtn" onclick="toggleView('person')" style="padding: 6px 12px; font-size: 0.8rem; border: none; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace; transition: all 0.2s; background: transparent; color: #888;">
                            👥 Por Persona
                        </button>
                    </div>
                    <button class="history-toggle" onclick="recategorizeAndGroup()" style="padding: 6px 12px; font-size: 0.8rem;">🔄 Recategorizar y Agrupar</button>
                    <button class="delete-btn" onclick="clearAllNotes()" style="padding: 8px 16px;">🗑️ Borrar Todo</button>
                </div>
            </div>
            <div class="notes-list" id="notesList">
                <div class="empty-state">No hay notas aún.<br>Empieza a escribir!</div>
            </div>
        </div>
    </div>

    <div class="history-panel" id="historyPanel">
        <div class="history-panel-header">
            <h3>📜 Historial Completo</h3>
            <button class="close-btn" onclick="toggleHistory()">Cerrar</button>
        </div>
        <div class="history-content" id="historyContent">
            <div class="empty-state">No hay historial aún</div>
        </div>
    </div>

    <!-- Panel de BUILD REVIEW -->
    <div class="review-panel" id="buildReviewPanel">
        <div class="review-header">
            <h3>📝 Build Review</h3>
            <div class="review-controls">
                <button class="close-btn" onclick="toggleBuildReviewMode()">Cerrar</button>
            </div>
        </div>
        <div class="review-filter-container">
            <!-- Filtros de días de la semana -->
            <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
                <span style="color: #888; font-size: 0.85rem; margin-right: 5px;">Día:</span>
                <button onclick="filterBuildReviewByDay('mon')" id="dayBtn-mon" class="day-filter-btn">LUN</button>
                <button onclick="filterBuildReviewByDay('tue')" id="dayBtn-tue" class="day-filter-btn">MAR</button>
                <button onclick="filterBuildReviewByDay('wed')" id="dayBtn-wed" class="day-filter-btn">MIE</button>
                <button onclick="filterBuildReviewByDay('thu')" id="dayBtn-thu" class="day-filter-btn">JUE</button>
                <button onclick="filterBuildReviewByDay('fri')" id="dayBtn-fri" class="day-filter-btn">VIE</button>
                <button onclick="filterBuildReviewByDay('sat')" id="dayBtn-sat" class="day-filter-btn">SAB</button>
                <button onclick="filterBuildReviewByDay('sun')" id="dayBtn-sun" class="day-filter-btn">DOM</button>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <button onclick="filterBuildReviewByDay('all')" id="dayBtn-all" class="day-filter-btn" style="font-weight: bold;">TODOS</button>
            </div>
            <!-- Checkbox ocultar aceptados -->
            <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                <input
                    type="checkbox"
                    id="buildReviewHideAcceptedCheckbox"
                    onchange="toggleBuildReviewHideAccepted()"
                    style="cursor: pointer;"
                >
                Ocultar aceptados
            </label>
        </div>
        <!-- Input para nuevas notas -->
        <div class="terminal-input-container" style="margin: 15px 20px;">
            <div class="terminal-input-wrapper">
                <span class="prompt">></span>
                <input
                    type="text"
                    id="buildReviewInput"
                    placeholder="Escribe aquí tu nota..."
                >
            </div>
        </div>
        <div class="review-content" id="buildReviewContent">
            <div class="empty-state">No hay notas para esta semana</div>
        </div>
    </div>

    <div class="review-panel" id="reviewPanel">
        <div class="review-header">
            <h3>✓ Modo Revisión</h3>
            <div class="review-controls">
                <button class="review-toggle" id="reviewGroupToggle" onclick="toggleReviewGrouping()">
                    Por Persona
                </button>
                <button class="close-btn" onclick="toggleReviewMode()">Cerrar</button>
            </div>
        </div>
        <div class="review-filter-container">
            <input
                type="text"
                id="reviewFilterInput"
                class="review-filter-input"
                placeholder="🔍 Filtrar por palabra clave..."
                oninput="filterReviewNotes()"
            >
            <div id="reviewPersonFilters" style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px;">
                <!-- Los filtros se generarán dinámicamente aquí -->
            </div>
        </div>
        <div class="review-content" id="reviewContent">
            <div class="empty-state">No hay notas para revisar</div>
        </div>
    </div>

    <script>
        // Inicializar Supabase
        const SUPABASE_URL = 'https://rhzfstnkavzqvcymavua.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJoemZzdG5rYXZ6cXZjeW1hdnVhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyMTQxMjgsImV4cCI6MjA3NTc5MDEyOH0.K6QTSU7uTvxPUIqSLS5_TI6bzmqV1hYswOpHyjLZcio';

        console.log('🔧 [INIT] Inicializando Supabase client...');
        console.log('🔧 [INIT] window.supabase disponible:', !!window.supabase);

        if (!window.supabase) {
            console.error('❌ [INIT] window.supabase NO está disponible! El CDN no cargó correctamente.');
            alert('ERROR: Supabase library no cargó. Revisa la consola.');
        }

        const { createClient } = window.supabase;
        console.log('🔧 [INIT] createClient function:', typeof createClient);

        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('✅ [INIT] Supabase client creado exitosamente');
        console.log('🔧 [INIT] Supabase URL:', SUPABASE_URL);
        console.log('🔧 [INIT] Key prefix:', SUPABASE_ANON_KEY.substring(0, 20) + '...');

        // Estado de la aplicación
        let notes = [];
        let history = [];
        let buildReviewMode = false; // Modo BUILD REVIEW
        let buildReviewSelectedDay = 'all'; // 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'all'
        let buildReviewHideAccepted = false; // Ocultar tareas aceptadas en build review
        let assignmentMode = false;
        let assignmentViewMode = 'category'; // 'category' o 'person'
        let assignmentHideAccepted = false; // Ocultar tareas aceptadas en modo asignación
        let assignmentFilterText = ''; // Texto del filtro de asignación
        let assignmentFilterPerson = null; // Filtro por persona en modo asignación (null = todas)
        let collapsedAssignments = new Set(); // IDs de notas con asignaciones colapsadas
        let editingAssignments = new Set(); // IDs de notas en modo de edición de asignación
        let reviewMode = false;
        let reviewGroupByPerson = true; // true = por persona, false = por categoría/tags
        let reviewFilterText = ''; // Texto del filtro de revisión
        let reviewFilterPerson = null; // Filtro por persona (null = todas)
        let reviewHideAccepted = false; // Ocultar tareas aceptadas

        // Lista de personas para asignar
        const people = ['VALEN', 'PABLO', 'MATI', 'LUKAKU', 'LUCASM', 'FEDEM', 'AGUS'];

        // Colores para cada persona
        const personColors = {
            'VALEN': '#ff6b9d',
            'PABLO': '#4ecdc4',
            'MATI': '#ffd93d',
            'LUKAKU': '#95e1d3',
            'LUCASM': '#c77dff',
            'FEDEM': '#ff9a56',
            'AGUS': '#70e000'
        };

        // Opciones de dificultad
        const difficulties = ['EASY', 'MEDIUM', 'HARD'];

        // Opciones de prioridad
        const priorities = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];

        // Estados de trabajo
        const workStatuses = ['not_started', 'wip', 'awaiting_review', 'accepted', 'rejected'];
        const workStatusLabels = {
            'not_started': '⭕ NO EMPEZADO',
            'wip': '🔄 WIP',
            'awaiting_review': '⏳ ESPERANDO REVISIÓN',
            'accepted': '✅ ACEPTADO',
            'rejected': '❌ RECHAZADO'
        };
        const workStatusColors = {
            'not_started': '#666',
            'wip': '#0088ff',
            'awaiting_review': '#ffaa00',
            'accepted': '#00ff88',
            'rejected': '#e94560'
        };

        // Tags conocidos del juego Eggscape
        const knownTags = [
            'PIECES', 'ENEMIGOS', 'FUNCTIONALITY', 'MODO EDIT', 'PAUSA', 'LAYERS', 'UI',
            'PACKS', 'SHD', 'OTHER', 'COLLECTABLES', 'COLLIDER', 'POLLERA', 'LOOK',
            'MENU WB', 'ROY', 'SOUND', 'HONOR', 'RANK', 'GREEDY PIGGY', 'LEVELS',
            'GRID', 'BACKEND', 'PLAY', 'FRENZY', 'WEAPONS', 'MARKET', 'GRABBABLES',
            'MATCHMAKING', 'VR MODE', 'SNAPPING', 'LOBBY', 'FRIENDING', 'AUTOSAVE',
            'VEHICLES', 'TUTORIAL', 'COMBAT', 'VOICECHAT', 'PERFORMANCE', 'TOOLS',
            'COSMETICS', 'BUILDER', 'POWERUPS', 'LOGS', 'CAMERA', 'RACE MODE'
        ];

        // ===== REVIEW MODE FUNCTIONS =====

        // Toggle modo revisión
        function toggleReviewMode() {
            reviewMode = !reviewMode;
            const btn = document.getElementById('reviewModeBtn');
            const panel = document.getElementById('reviewPanel');
            const mainContainer = document.querySelector('.main-container');

            if (reviewMode) {
                btn.classList.add('active');
                panel.classList.add('active');
                mainContainer.classList.add('review-active');
                renderPersonFilters();
                renderReviewMode();
            } else {
                btn.classList.remove('active');
                panel.classList.remove('active');
                mainContainer.classList.remove('review-active');
            }
        }

        // Renderizar filtros de personas
        function renderPersonFilters() {
            const container = document.getElementById('reviewPersonFilters');
            if (!container) return;

            let html = `
                <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                    <input
                        type="checkbox"
                        id="hideAcceptedCheckbox"
                        onchange="toggleHideAccepted()"
                        style="cursor: pointer;"
                        ${reviewHideAccepted ? 'checked' : ''}
                    >
                    Ocultar aceptados
                </label>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <span style="color: #888; font-size: 0.85rem;">Filtrar por persona:</span>
                <button
                    onclick="filterByPerson(null)"
                    style="padding: 4px 10px; background: ${reviewFilterPerson === null ? '#00ff88' : '#16213e'}; color: ${reviewFilterPerson === null ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${reviewFilterPerson === null ? 'bold' : 'normal'};"
                >
                    Todas
                </button>
            `;

            people.forEach(person => {
                html += `
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <button
                            onclick="filterByPerson('${person}')"
                            style="padding: 4px 10px; background: ${reviewFilterPerson === person ? '#00ff88' : '#16213e'}; color: ${reviewFilterPerson === person ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${reviewFilterPerson === person ? 'bold' : 'normal'};"
                        >
                            ${person}
                        </button>
                        <button
                            onclick="copyPersonLink('${person}', event)"
                            style="padding: 4px 8px; background: #16213e; color: #00ff88; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem;"
                            title="Copiar link personal de ${person}"
                        >
                            📋
                        </button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filtrar por persona
        function filterByPerson(person) {
            reviewFilterPerson = person;
            renderPersonFilters();
            renderReviewMode();
        }

        // Copiar link personal
        function copyPersonLink(person, event) {
            const personLower = person.toLowerCase();
            const baseUrl = window.location.origin + window.location.pathname;
            const personalUrl = `${baseUrl}?person=${personLower}`;

            // Intentar copiar al portapapeles
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(personalUrl).then(() => {
                    // Mostrar notificación de éxito
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = '✓';
                    button.style.background = '#00ff88';
                    button.style.color = '#0a0a0f';

                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#16213e';
                        button.style.color = '#00ff88';
                    }, 1500);
                }).catch(err => {
                    console.error('Error copiando link:', err);
                    // Fallback: mostrar el link en un prompt
                    prompt('Copia este link:', personalUrl);
                });
            } else {
                // Fallback si no hay soporte para clipboard API
                prompt('Copia este link:', personalUrl);
            }
        }

        // Renderizar filtros de personas para modo asignación
        function renderAssignmentFilters() {
            const container = document.getElementById('assignmentPersonFilters');
            if (!container) return;

            let html = `
                <label style="display: flex; align-items: center; gap: 6px; color: #00ff88; font-size: 0.9rem; cursor: pointer;">
                    <input
                        type="checkbox"
                        id="assignmentHideAcceptedCheckbox"
                        onchange="toggleAssignmentHideAccepted()"
                        style="cursor: pointer;"
                        ${assignmentHideAccepted ? 'checked' : ''}
                    >
                    Ocultar aceptados
                </label>
                <div style="border-left: 2px solid #16213e; height: 20px; margin: 0 5px;"></div>
                <span style="color: #888; font-size: 0.85rem;">Filtrar por persona:</span>
                <button
                    onclick="filterAssignmentByPerson(null)"
                    style="padding: 4px 10px; background: ${assignmentFilterPerson === null ? '#00ff88' : '#16213e'}; color: ${assignmentFilterPerson === null ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${assignmentFilterPerson === null ? 'bold' : 'normal'};"
                >
                    Todas
                </button>
            `;

            people.forEach(person => {
                html += `
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <button
                            onclick="filterAssignmentByPerson('${person}')"
                            style="padding: 4px 10px; background: ${assignmentFilterPerson === person ? '#00ff88' : '#16213e'}; color: ${assignmentFilterPerson === person ? '#0a0a0f' : '#00ff88'}; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: ${assignmentFilterPerson === person ? 'bold' : 'normal'};"
                        >
                            ${person}
                        </button>
                        <button
                            onclick="copyPersonLink('${person}', event)"
                            style="padding: 4px 8px; background: #16213e; color: #00ff88; border: 1px solid #00ff8844; border-radius: 4px; cursor: pointer; font-size: 0.85rem;"
                            title="Copiar link personal de ${person}"
                        >
                            📋
                        </button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filtrar por persona en modo asignación
        function filterAssignmentByPerson(person) {
            assignmentFilterPerson = person;
            renderAssignmentFilters();
            renderNotes();
        }

        // Filtrar por texto en modo asignación
        function filterAssignmentNotes() {
            const input = document.getElementById('assignmentFilterInput');
            assignmentFilterText = input.value.toLowerCase();
            renderNotes();
        }

        // Toggle ocultar aceptados
        function toggleHideAccepted() {
            const checkbox = document.getElementById('hideAcceptedCheckbox');
            reviewHideAccepted = checkbox.checked;
            renderReviewMode();
        }

        // Toggle agrupamiento (persona vs categoría)
        function toggleReviewGrouping() {
            reviewGroupByPerson = !reviewGroupByPerson;
            const btn = document.getElementById('reviewGroupToggle');
            btn.textContent = reviewGroupByPerson ? 'Por Persona' : 'Por Categoría';
            renderReviewMode();
        }

        // Filtrar notas en review mode
        function filterReviewNotes() {
            const input = document.getElementById('reviewFilterInput');
            reviewFilterText = input.value.toLowerCase().trim();
            renderReviewMode();
        }

        // ===== BUILD REVIEW FUNCTIONS =====

        // Toggle modo BUILD REVIEW
        function toggleBuildReviewMode() {
            buildReviewMode = !buildReviewMode;
            const btn = document.getElementById('buildReviewModeBtn');
            const panel = document.getElementById('buildReviewPanel');
            const mainContainer = document.querySelector('.main-container');

            if (buildReviewMode) {
                btn.classList.add('active');
                panel.classList.add('active');
                mainContainer.classList.add('review-active');

                // Marcar el botón del día actual como activo si ninguno está activo
                const activeDayBtn = document.querySelector('.day-filter-btn.active');
                if (!activeDayBtn) {
                    // Marcar "TODOS" por defecto
                    const allBtn = document.getElementById('dayBtn-all');
                    if (allBtn) allBtn.classList.add('active');
                }

                renderBuildReview();
            } else {
                btn.classList.remove('active');
                panel.classList.remove('active');
                mainContainer.classList.remove('review-active');
            }
        }

        // Filtrar BUILD REVIEW por día
        function filterBuildReviewByDay(day) {
            buildReviewSelectedDay = day;

            // Actualizar estilos de botones
            const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'all'];
            days.forEach(d => {
                const btn = document.getElementById(`dayBtn-${d}`);
                if (btn) {
                    if (d === day) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });

            renderBuildReview();
        }

        // Toggle ocultar aceptados en BUILD REVIEW
        function toggleBuildReviewHideAccepted() {
            const checkbox = document.getElementById('buildReviewHideAcceptedCheckbox');
            buildReviewHideAccepted = checkbox.checked;
            renderBuildReview();
        }

        // Obtener día de la semana de una fecha (0=Domingo, 1=Lunes, ...)
        function getDayOfWeek(dateString) {
            const date = new Date(dateString);
            return date.getDay(); // 0=Domingo, 1=Lunes, ..., 6=Sábado
        }

        // Mapear día de la semana a código
        function getDayCode(dayNumber) {
            const dayMap = {
                0: 'sun',
                1: 'mon',
                2: 'tue',
                3: 'wed',
                4: 'thu',
                5: 'fri',
                6: 'sat'
            };
            return dayMap[dayNumber];
        }

        // Obtener inicio de la semana actual (Lunes)
        function getStartOfWeek(date = new Date()) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Ajustar cuando es domingo
            return new Date(d.setDate(diff));
        }

        // Obtener fin de la semana actual (Domingo)
        function getEndOfWeek(date = new Date()) {
            const start = getStartOfWeek(date);
            const end = new Date(start);
            end.setDate(start.getDate() + 6);
            return end;
        }

        // Renderizar BUILD REVIEW
        function renderBuildReview() {
            const container = document.getElementById('buildReviewContent');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para esta semana</div>';
                return;
            }

            // Filtrar notas de la semana actual
            const weekStart = getStartOfWeek();
            const weekEnd = getEndOfWeek();
            weekEnd.setHours(23, 59, 59, 999);

            let filteredNotes = notes.filter(note => {
                const noteDate = new Date(note.buildReviewDate);
                return noteDate >= weekStart && noteDate <= weekEnd;
            });

            // Filtrar por día seleccionado
            if (buildReviewSelectedDay !== 'all') {
                filteredNotes = filteredNotes.filter(note => {
                    const dayOfWeek = getDayOfWeek(note.buildReviewDate);
                    const dayCode = getDayCode(dayOfWeek);
                    return dayCode === buildReviewSelectedDay;
                });
            }

            // Filtrar ocultar aceptados
            if (buildReviewHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para este día</div>';
                return;
            }

            // Renderizar lista simple
            let html = '<div style="padding: 10px;">';
            filteredNotes.forEach(note => {
                const dayOfWeek = getDayOfWeek(note.buildReviewDate);
                const dayCode = getDayCode(dayOfWeek);
                const dayNames = {
                    'mon': 'Lunes',
                    'tue': 'Martes',
                    'wed': 'Miércoles',
                    'thu': 'Jueves',
                    'fri': 'Viernes',
                    'sat': 'Sábado',
                    'sun': 'Domingo'
                };

                html += `<div style="background: #0f0f1a; padding: 15px; margin-bottom: 10px; border-radius: 5px; border-left: 3px solid #00ff88;">`;

                // Mostrar día si estamos en vista "TODOS"
                if (buildReviewSelectedDay === 'all') {
                    html += `<div style="color: #888; font-size: 0.85rem; margin-bottom: 5px;">${dayNames[dayCode]}</div>`;
                }

                html += `<div style="color: #eee; margin-bottom: 10px;">${escapeHtml(note.text)}</div>`;

                // Mostrar categoría y tags si ya fueron procesados
                if (note.aiProcessed) {
                    html += `<div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">`;
                    html += `<span style="background: #16213e; color: #00ff88; padding: 3px 8px; border-radius: 3px; font-size: 0.85rem;">${note.category}</span>`;
                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            html += `<span style="background: #1a1a2e; color: #888; padding: 3px 8px; border-radius: 3px; font-size: 0.85rem;">${tag}</span>`;
                        });
                    }
                    html += `</div>`;
                }

                html += `</div>`;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        // Roll-over semanal: mover notas no aceptadas al lunes actual
        async function performWeeklyRollover() {
            const today = new Date();
            const dayOfWeek = today.getDay();

            // Solo ejecutar el roll-over los lunes (día 1)
            if (dayOfWeek !== 1) {
                return;
            }

            // Obtener la semana actual (número de semana del año)
            const weekNumber = getWeekNumber(today);
            const lastRolloverWeek = localStorage.getItem('lastRolloverWeek');

            // Si ya se hizo el roll-over esta semana, salir
            if (lastRolloverWeek && parseInt(lastRolloverWeek) === weekNumber) {
                console.log('✅ Roll-over ya ejecutado esta semana');
                return;
            }

            console.log('🔄 Ejecutando roll-over semanal...');

            // Obtener inicio de la semana actual (este lunes)
            const thisMonday = getStartOfWeek(today);

            // Buscar notas NO aceptadas de semanas anteriores
            let notesRolledOver = 0;
            notes.forEach(note => {
                const noteDate = new Date(note.buildReviewDate);

                // Si la nota es de una semana anterior Y NO está aceptada
                if (noteDate < thisMonday && note.reviewStatus !== 'accepted') {
                    // Mover al lunes de esta semana
                    note.buildReviewDate = thisMonday.toISOString();
                    notesRolledOver++;
                }
            });

            // Guardar que ya se hizo el roll-over esta semana
            localStorage.setItem('lastRolloverWeek', weekNumber.toString());

            if (notesRolledOver > 0) {
                console.log(`✅ Roll-over completado: ${notesRolledOver} notas movidas al lunes`);
                await saveToLocalStorage();
            } else {
                console.log('✅ Roll-over completado: no hay notas para mover');
            }
        }

        // Obtener número de semana del año
        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        // Renderizar modo revisión
        function renderReviewMode() {
            const container = document.getElementById('reviewContent');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas para revisar</div>';
                return;
            }

            // Filtrar notas
            let filteredNotes = notes;

            // Filtro por texto de búsqueda
            if (reviewFilterText) {
                filteredNotes = filteredNotes.filter(note => {
                    // Buscar en el texto de la nota
                    if (note.text.toLowerCase().includes(reviewFilterText)) return true;
                    // Buscar en la categoría
                    if (note.category && note.category.toLowerCase().includes(reviewFilterText)) return true;
                    // Buscar en los tags
                    if (note.tags && note.tags.some(tag => tag.toLowerCase().includes(reviewFilterText))) return true;
                    // Buscar en las personas asignadas
                    if (note.assignedTo && note.assignedTo.some(person => person.toLowerCase().includes(reviewFilterText))) return true;
                    return false;
                });
            }

            // Filtro por persona
            if (reviewFilterPerson) {
                filteredNotes = filteredNotes.filter(note => {
                    return note.assignedTo && note.assignedTo.includes(reviewFilterPerson);
                });
            }

            // Filtro para ocultar aceptados
            if (reviewHideAccepted) {
                filteredNotes = filteredNotes.filter(note => {
                    return note.reviewStatus !== 'accepted';
                });
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No se encontraron notas con ese filtro</div>';
                return;
            }

            let html = '';

            if (reviewGroupByPerson) {
                // Agrupar por persona
                const byPerson = {};
                const unassigned = [];

                filteredNotes.forEach(note => {
                    if (note.assignedTo && note.assignedTo.length > 0) {
                        note.assignedTo.forEach(person => {
                            // Si hay un filtro de persona activo, solo mostrar esa persona
                            if (reviewFilterPerson && person !== reviewFilterPerson) {
                                return; // Saltar esta persona
                            }
                            if (!byPerson[person]) byPerson[person] = [];
                            byPerson[person].push(note);
                        });
                    } else {
                        unassigned.push(note);
                    }
                });

                // Renderizar por persona
                const sortedPeople = Object.keys(byPerson).sort();
                sortedPeople.forEach(person => {
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>👤 ${person}</span>
                            <span class="review-person-count">${byPerson[person].length} tarea${byPerson[person].length !== 1 ? 's' : ''}</span>
                        </div>`;
                    byPerson[person].forEach(note => {
                        html += renderReviewItem(note);
                    });
                    html += `</div>`;
                });

                // Sin asignar
                if (unassigned.length > 0) {
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>📋 Sin Asignar</span>
                            <span class="review-person-count">${unassigned.length} tarea${unassigned.length !== 1 ? 's' : ''}</span>
                        </div>`;
                    unassigned.forEach(note => {
                        html += renderReviewItem(note);
                    });
                    html += `</div>`;
                }
            } else {
                // Agrupar por categoría y tags
                const grouped = {};
                filteredNotes.forEach(note => {
                    const category = note.category || 'Other';
                    if (!grouped[category]) grouped[category] = {};

                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            if (!grouped[category][tag]) grouped[category][tag] = [];
                            grouped[category][tag].push(note);
                        });
                    } else {
                        if (!grouped[category]['General']) grouped[category]['General'] = [];
                        grouped[category]['General'].push(note);
                    }
                });

                // Renderizar por categoría
                Object.entries(grouped).forEach(([category, tagGroups]) => {
                    const totalInCategory = Object.values(tagGroups).flat().length;
                    html += `<div class="review-person-section">
                        <div class="review-person-title">
                            <span>${getCategoryEmoji(category)} ${category}</span>
                            <span class="review-person-count">${totalInCategory} tarea${totalInCategory !== 1 ? 's' : ''}</span>
                        </div>`;

                    Object.entries(tagGroups).forEach(([tag, tagNotes]) => {
                        html += `<div style="margin-bottom: 30px;">
                            <div style="color: #888; font-size: 1rem; font-weight: bold; margin-bottom: 15px; padding-left: 10px; border-left: 3px solid #888;">
                                ${tag} <span style="color: #666; font-weight: normal;">(${tagNotes.length})</span>
                            </div>`;
                        tagNotes.forEach(note => {
                            html += renderReviewItem(note);
                        });
                        html += `</div>`;
                    });

                    html += `</div>`;
                });
            }

            container.innerHTML = html;
        }

        // Renderizar un item de revisión
        function renderReviewItem(note) {
            const currentStatus = note.workStatus || 'not_started';
            const statusColor = workStatusColors[currentStatus];
            const statusLabel = workStatusLabels[currentStatus];

            let html = `<div class="review-item">`;

            // ===== STATUS ARRIBA (muy separado) =====
            html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #1a1a2e;">`;

            // Status actual (clickeable para dropdown)
            html += `<div style="position: relative;">
                <div class="work-status-badge"
                     onclick="toggleWorkStatusSelector(${note.id}, event)"
                     style="background: ${statusColor}; cursor: pointer; font-size: 1rem; padding: 8px 16px;">
                    ${statusLabel}
                </div>

                <!-- Dropdown de estados -->
                <div class="work-status-selector" id="work-status-selector-${note.id}">
                    <button class="work-status-option" style="background: ${workStatusColors.not_started};" onclick="setWorkStatus(${note.id}, 'not_started', event)">⭕ NO EMPEZADO</button>
                    <button class="work-status-option" style="background: ${workStatusColors.wip};" onclick="setWorkStatus(${note.id}, 'wip', event)">🔄 WIP</button>
                    <button class="work-status-option" style="background: ${workStatusColors.awaiting_review};" onclick="setWorkStatus(${note.id}, 'awaiting_review', event)">⏳ ESPERANDO REVISIÓN</button>
                    <button class="work-status-option" style="background: ${workStatusColors.accepted};" onclick="setWorkStatus(${note.id}, 'accepted', event)">✅ ACEPTADO</button>
                    <button class="work-status-option" style="background: ${workStatusColors.rejected};" onclick="setWorkStatus(${note.id}, 'rejected', event)">❌ RECHAZADO</button>
                </div>
            </div>`;

            // Botón de siguiente estado
            if (currentStatus === 'not_started') {
                html += `<button onclick="advanceWorkStatus(${note.id})" style="padding: 8px 16px; background: ${workStatusColors.wip}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.95rem;">▶ Empezar</button>`;
            } else if (currentStatus === 'wip') {
                html += `<button onclick="advanceWorkStatus(${note.id})" style="padding: 8px 16px; background: ${workStatusColors.awaiting_review}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.95rem;">✓ Listo para Revisión</button>`;
            } else if (currentStatus === 'awaiting_review') {
                html += `<button onclick="setWorkStatus(${note.id}, 'accepted', event)" style="padding: 6px 12px; background: ${workStatusColors.accepted}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.9rem; margin-right: 5px;">✓ Aceptar</button>`;
                html += `<button onclick="setWorkStatus(${note.id}, 'rejected', event)" style="padding: 6px 12px; background: ${workStatusColors.rejected}; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 0.9rem;">✗ Rechazar</button>`;
            }

            html += `</div>`;

            // ===== TEXTO DE LA NOTA =====
            html += `<div class="review-item-text" style="margin-bottom: 15px; font-size: 1.05rem;">${escapeHtml(note.text)}</div>`;

            // ===== TODO LO DEMÁS ABAJO =====
            html += `<div class="review-item-meta" style="display: flex; gap: 8px; flex-wrap: wrap;">`;

            // Categoría
            if (note.category) {
                html += `<span class="review-meta-badge">${getCategoryEmoji(note.category)} ${note.category}</span>`;
            }

            // Tags
            if (note.tags && note.tags.length > 0) {
                note.tags.forEach(tag => {
                    html += `<span class="review-meta-badge">${tag}</span>`;
                });
            }

            // Personas asignadas
            if (note.assignedTo && note.assignedTo.length > 0) {
                note.assignedTo.forEach(person => {
                    const personColor = personColors[person] || '#ff88ff';
                    html += `<span class="review-meta-badge" style="background: ${personColor}; color: #000; font-weight: bold;">👤 ${person}</span>`;
                });
            }

            // Dificultad
            if (note.difficulty) {
                html += `<span class="review-meta-badge" style="background: #1a3a2e;">📊 ${note.difficulty.toUpperCase()}</span>`;
            }

            // Prioridad
            if (note.priority) {
                html += `<span class="review-meta-badge" style="background: ${getPriorityColor(note.priority)};">⚡ <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>`;
            }

            html += `</div>`;

            // Comentario de rechazo si existe
            if (note.workStatus === 'rejected' && note.rejectionComment) {
                html += `<div class="review-comment-display" style="margin-top: 10px;">
                    <strong>Comentario:</strong> ${escapeHtml(note.rejectionComment)}
                </div>`;
            }

            html += `</div>`;
            return html;
        }

        // Avanzar al siguiente estado de trabajo
        function advanceWorkStatus(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex === -1) return;

            const currentStatus = notes[noteIndex].workStatus || 'not_started';
            let nextStatus = currentStatus;

            if (currentStatus === 'not_started') {
                nextStatus = 'wip';
            } else if (currentStatus === 'wip') {
                nextStatus = 'awaiting_review';
            }

            notes[noteIndex].workStatus = nextStatus;
            saveToLocalStorage();
            addToHistory('work_status', `"${notes[noteIndex].text}" → ${workStatusLabels[nextStatus]}`);
            renderReviewMode();
        }

        // Aceptar nota
        function acceptNote(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].reviewStatus = 'accepted';
                notes[noteIndex].rejectionComment = '';
                saveToLocalStorage();
                addToHistory('review', `Aceptada: "${notes[noteIndex].text}"`);
                renderReviewMode();
            }
        }

        // Mostrar input para rechazar nota
        function showRejectInput(noteId) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex === -1) return;

            // Renderizar de nuevo mostrando el input
            const container = document.getElementById('reviewContent');
            const currentScroll = container.scrollTop;

            renderReviewMode();

            // Buscar el item y agregar el input
            const items = container.querySelectorAll('.review-item');
            let targetItem = null;

            // Encontrar el item correcto por su texto
            for (const item of items) {
                const textDiv = item.querySelector('.review-item-text');
                if (textDiv && textDiv.textContent === notes[noteIndex].text) {
                    targetItem = item;
                    break;
                }
            }

            if (targetItem) {
                const actionsDiv = targetItem.querySelector('.review-actions');
                if (actionsDiv) {
                    actionsDiv.innerHTML = `
                        <input type="text"
                               class="review-comment-input"
                               id="reject-comment-${noteId}"
                               placeholder="Ingresa el comentario y presiona Enter..."
                               onkeypress="if(event.key==='Enter') saveRejection(${noteId}, this.value)"
                               style="width: 100%; margin-top: 10px;">
                    `;

                    // Auto-focus y mantener scroll
                    setTimeout(() => {
                        const input = document.getElementById(`reject-comment-${noteId}`);
                        if (input) {
                            input.focus();
                            container.scrollTop = currentScroll;
                        }
                    }, 50);
                }
            }
        }

        // Guardar rechazo con comentario
        function saveRejection(noteId, comment) {
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].reviewStatus = 'rejected';
                notes[noteIndex].rejectionComment = comment.trim();
                saveToLocalStorage();
                addToHistory('review', `Rechazada: "${notes[noteIndex].text}" - ${comment}`);
                renderReviewMode();
            }
        }

        // Inicializar
        async function init() {
            await loadFromLocalStorage();

            // Ejecutar roll-over semanal (solo lunes, solo una vez por semana)
            await performWeeklyRollover();

            // Detectar si hay un parámetro person en la URL
            const urlParams = new URLSearchParams(window.location.search);
            const personParam = urlParams.get('person');

            if (personParam) {
                // Modo personal: activar modo revisión con filtro de persona
                const personUpper = personParam.toUpperCase();
                if (people.includes(personUpper)) {
                    // Desactivar BUILD REVIEW y activar REVIEW MODE
                    buildReviewMode = false;
                    reviewMode = true;
                    reviewFilterPerson = personUpper;
                    reviewGroupByPerson = true;

                    // Actualizar botones
                    document.getElementById('buildReviewModeBtn').classList.remove('active');
                    document.getElementById('buildReviewPanel').classList.remove('active');
                    document.getElementById('reviewModeBtn').classList.add('active');
                    document.getElementById('reviewPanel').classList.add('active');
                    document.querySelector('.main-container').classList.add('review-active');

                    renderPersonFilters();
                    renderReviewMode();
                    return; // No continuar con la inicialización normal
                }
            }

            // Vista de notas organizadas es el modo default
            renderNotes();
            renderHistory();

            // Configurar Enter para agregar nota
            const input = document.getElementById('terminalInput');
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addNote(); // NO AWAIT - no bloquear
                }
            });

            // Configurar Enter para agregar nota desde BUILD REVIEW
            const buildReviewInput = document.getElementById('buildReviewInput');
            buildReviewInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addNote(); // NO AWAIT - no bloquear
                }
            });

            // Mantener focus en el input (solo si no hay selección de texto)
            document.addEventListener('click', (e) => {
                const hasSelection = window.getSelection().toString().length > 0;
                if (!hasSelection && !e.target.closest('.note-card') && !e.target.closest('.history-panel') && !e.target.closest('.delete-btn')) {
                    input.focus();
                }
            });
        }

        // Agregar nota - NO ASYNC
        function addNote() {
            const mainInput = document.getElementById('terminalInput');
            const buildInput = document.getElementById('buildReviewInput');

            // Intentar obtener texto de ambos inputs
            let text = '';
            let activeInput = null;

            if (mainInput && mainInput.value.trim()) {
                text = mainInput.value.trim();
                activeInput = mainInput;
            } else if (buildInput && buildInput.value.trim()) {
                text = buildInput.value.trim();
                activeInput = buildInput;
            }

            if (!text) return;

            // Crear nota inmediatamente
            const note = {
                id: Date.now(),
                text: text,
                category: 'Other', // Default inmediato
                tags: [],
                priority: null, // Sin prioridad por defecto
                difficulty: null, // Sin dificultad por defecto
                assignedTo: [], // Sin asignaciones por defecto
                reviewStatus: null, // 'accepted' | 'rejected' | null
                rejectionComment: '', // Comentario si fue rechazado
                workStatus: 'not_started', // Estado de trabajo
                timestamp: new Date().toISOString(),
                buildReviewDate: new Date().toISOString(), // Fecha de build review
                aiProcessed: false
            };

            notes.push(note);
            addTerminalLine(text, note.id);

            // Limpiar input INMEDIATAMENTE
            activeInput.value = '';
            activeInput.focus();

            // Guardar y renderizar INMEDIATAMENTE
            saveToLocalStorage();
            renderNotes();
            if (buildReviewMode) {
                renderBuildReview(); // Actualizar BUILD REVIEW también
            }

            // Procesar con AI en background (no bloquea)
            processWithAI(note); // Sin await - corre en background
        }

        // Agregar línea al terminal
        function addTerminalLine(text, noteId) {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            line.id = `line-${noteId}`;
            renderTerminalLine(line, noteId, text);
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        // Renderizar contenido de línea terminal
        function renderTerminalLine(lineElement, noteId, text) {
            const note = notes.find(n => n.id === noteId);
            if (!note) return;

            // Verificar si esta nota específica está colapsada (ya se le dio aceptar)
            const isCollapsed = collapsedAssignments.has(noteId);

            // Verificar si está en modo de edición de asignación
            const isEditingAssignment = editingAssignments.has(noteId);

            // Verificar si la tarea ya tiene asignaciones
            const hasAssignments = (note.assignedTo && note.assignedTo.length > 0) || note.difficulty || note.priority;

            // Mostrar UI de asignación solo si:
            // - Estamos en modo asignación
            // - NO está colapsada
            // - NO tiene asignaciones previas O está en modo de edición
            const showAssignmentUI = assignmentMode && !isCollapsed && (!hasAssignments || isEditingAssignment);

            // Mostrar vista de asignación existente con opción de editar si:
            // - Estamos en modo asignación
            // - NO está colapsada
            // - SÍ tiene asignaciones previas
            // - NO está en modo de edición
            const showAssignedWithEdit = assignmentMode && !isCollapsed && hasAssignments && !isEditingAssignment;

            lineElement.innerHTML = `
                <div class="terminal-line-main">
                    <div class="terminal-line-text">
                        <span class="prompt">></span>
                        <span class="text">${escapeHtml(text)}</span>
                    </div>
                    <div class="ai-processing" id="status-${noteId}" style="color: #ffa500; font-size: 0.85rem;">🤖 AI procesando...</div>
                </div>
                ${showAssignmentUI ? `
                    <div class="assignment-section" id="assignment-terminal-${noteId}" style="margin-top: 8px;">
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">👥 ASIGNAR A:</div>
                            <div class="assignment-people">
                                ${people.map(person => `
                                    <label class="person-checkbox ${note.assignedTo && note.assignedTo.includes(person) ? 'selected' : ''}" onclick="togglePerson(${noteId}, '${person}', event)">
                                        <input type="checkbox" value="${person}" ${note.assignedTo && note.assignedTo.includes(person) ? 'checked' : ''}>
                                        ${person}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">📊 DIFICULTAD:</div>
                            <div class="assignment-people">
                                ${difficulties.map(diff => `
                                    <label class="person-checkbox ${note.difficulty === diff.toLowerCase() ? 'selected' : ''}" onclick="selectDifficulty(${noteId}, '${diff.toLowerCase()}', event)">
                                        <input type="radio" name="difficulty-${noteId}" value="${diff.toLowerCase()}" ${note.difficulty === diff.toLowerCase() ? 'checked' : ''}>
                                        ${diff}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="color: #888; font-size: 0.7rem; margin-bottom: 4px;">⚡ PRIORIDAD:</div>
                            <div class="assignment-people">
                                ${priorities.map(prio => `
                                    <label class="person-checkbox ${note.priority === prio.toLowerCase() ? 'selected' : ''}" onclick="selectPriority(${noteId}, '${prio.toLowerCase()}', event)">
                                        <input type="radio" name="priority-${noteId}" value="${prio.toLowerCase()}" ${note.priority === prio.toLowerCase() ? 'checked' : ''}>
                                        ${prio}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <button class="save-btn" onclick="assignPeople(${noteId}, event)">✓ Aceptar</button>
                    </div>
                ` : showAssignedWithEdit ? `
                    <div style="margin-top: 6px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                        ${note.assignedTo && note.assignedTo.length > 0 ? `
                            ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">👤 ${person}</span>`).join('')}
                        ` : ''}
                        ${note.difficulty ? `<span class="assigned-person" style="background: #1a3a2e; border-color: #00ff8888;">📊 ${note.difficulty.toUpperCase()}</span>` : ''}
                        ${note.priority ? `<span class="assigned-person" style="background: ${getPriorityColor(note.priority)}; border-color: ${getPriorityColor(note.priority)};">⚡ <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>` : ''}
                        <button class="edit-btn" onclick="enableAssignmentEdit(${noteId}, event)" style="margin-left: 4px; padding: 4px 8px; font-size: 0.8rem;" title="Editar asignación">✎</button>
                    </div>
                ` : hasAssignments ? `
                    <div style="margin-top: 6px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                        ${note.assignedTo && note.assignedTo.length > 0 ? `
                            ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">👤 ${person}</span>`).join('')}
                        ` : ''}
                        ${note.difficulty ? `<span class="assigned-person" style="background: #1a3a2e; border-color: #00ff8888;">📊 ${note.difficulty.toUpperCase()}</span>` : ''}
                        ${note.priority ? `<span class="assigned-person" style="background: ${getPriorityColor(note.priority)}; border-color: ${getPriorityColor(note.priority)};">⚡ <span style="color: #000; font-weight: bold;">${note.priority.toUpperCase()}</span></span>` : ''}
                    </div>
                ` : ''}
            `;
        }

        // Actualizar estado en terminal
        function updateTerminalLine(noteId, message, isError = false, category = null, tags = null) {
            const status = document.getElementById(`status-${noteId}`);
            if (status) {
                if (category && tags) {
                    // Mostrar con badges visuales
                    const tagsHtml = tags.length > 0
                        ? tags.map(tag => `<span class="terminal-tag">${tag}</span>`).join('')
                        : '';
                    status.innerHTML = `
                        <div class="ai-result">
                            <span style="color: #00ff88;">✓</span>
                            <span class="terminal-category-badge">${getCategoryEmoji(category)} ${category}</span>
                            ${tagsHtml}
                        </div>
                    `;
                } else {
                    // Mostrar mensaje simple
                    status.textContent = message;
                    status.style.color = isError ? '#e94560' : '#00ff88';
                }
            }
        }

        // Procesar con AI - async pero no bloquea
        async function processWithAI(note) {
            console.log('🤖 Procesando con AI:', note.text);

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                // TODO: Migrar a Supabase Edge Function
                // const response = await fetch('/api/categorize', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json'
                //     },
                //     body: JSON.stringify({ text: note.text }),
                //     signal: controller.signal
                // });

                // Por ahora: categorización manual (temporal)
                throw new Error('AI categorization temporalmente deshabilitada - usa categoría manual');

                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Error de la API:', errorText);
                    throw new Error(`API returned ${response.status}`);
                }

                // Intentar parsear JSON con mejor manejo de errores
                let data;
                try {
                    const textResponse = await response.text();
                    if (!textResponse || textResponse.trim().length === 0) {
                        throw new Error('Respuesta vacía de la API');
                    }
                    data = JSON.parse(textResponse);
                    console.log('📦 Respuesta API completa:', data);
                } catch (parseError) {
                    console.error('❌ Error parseando JSON:', parseError);
                    throw new Error('Respuesta inválida de la API');
                }

                // Verificar estructura de la respuesta
                if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                    console.error('❌ Respuesta sin contenido:', data);
                    throw new Error('Respuesta sin contenido');
                }

                if (!data.content[0] || !data.content[0].text) {
                    console.error('❌ Formato de respuesta inválido:', data);
                    throw new Error('Formato inválido');
                }

                const content = data.content[0].text.trim();
                console.log('📝 Texto de respuesta:', content);

                const jsonMatch = content.match(/\{[\s\S]*\}/);
                console.log('🔍 JSON extraído:', jsonMatch ? jsonMatch[0] : 'NO MATCH');

                if (!jsonMatch) {
                    throw new Error('Sin JSON en respuesta');
                }

                const suggestion = JSON.parse(jsonMatch[0]);
                console.log('✅ Objeto parseado:', suggestion);
                console.log('  → Category:', suggestion.category);
                console.log('  → Tags:', suggestion.tags);

                // Actualizar nota
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].category = suggestion.category || 'Other';
                    notes[noteIndex].tags = suggestion.tags || [];
                    notes[noteIndex].aiProcessed = true;

                    // Actualizar terminal con badges visuales
                    updateTerminalLine(note.id, null, false, suggestion.category, suggestion.tags || []);

                    const tagStr = suggestion.tags?.length > 0 ? ` [${suggestion.tags.join(', ')}]` : '';
                    addToHistory('add', `"${note.text}" → ${suggestion.category}${tagStr}`);

                    saveToLocalStorage();
                    renderNotes();
                }

            } catch (error) {
                console.error('❌ AI Error completo:', error);
                console.error('❌ Error name:', error.name);
                console.error('❌ Error message:', error.message);
                console.error('❌ Error stack:', error.stack);

                updateTerminalLine(note.id, `⚠️ Error: ${error.message}`, true);

                // Ya está guardada como "Other", solo marcar como procesada
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].aiProcessed = true;
                    saveToLocalStorage();
                }
            }
        }

        // Eliminar nota
        function deleteNote(id, event) {
            event.stopPropagation();
            const note = notes.find(n => n.id === id);
            if (note && confirm('¿Eliminar esta nota?')) {
                addToHistory('delete', `Eliminada: "${note.text}"`);
                notes = notes.filter(n => n.id !== id);

                const line = document.getElementById(`line-${id}`);
                if (line) line.remove();

                saveToLocalStorage();
                renderNotes();
            }
        }

        // Editar nota
        let editingNoteId = null;

        function startEditNote(id, event) {
            event.stopPropagation();
            editingNoteId = id;
            renderNotes();
        }

        function saveEditNote(id, event) {
            event.stopPropagation();
            const input = document.getElementById(`edit-input-${id}`);
            const newText = input.value.trim();

            if (!newText) {
                alert('La nota no puede estar vacía');
                return;
            }

            const noteIndex = notes.findIndex(n => n.id === id);
            if (noteIndex !== -1) {
                const oldText = notes[noteIndex].text;
                notes[noteIndex].text = newText;
                notes[noteIndex].aiProcessed = false;

                addToHistory('edit', `Editada: "${oldText}" → "${newText}"`);

                // Actualizar terminal
                const line = document.getElementById(`line-${id}`);
                if (line) {
                    const textSpan = line.querySelector('.text');
                    if (textSpan) textSpan.textContent = newText;
                    updateTerminalLine(id, '🤖 AI procesando...', false);
                }

                saveToLocalStorage();
                editingNoteId = null;
                renderNotes();

                // Re-procesar con AI
                processWithAI(notes[noteIndex]);
            }
        }

        function cancelEditNote(event) {
            event.stopPropagation();
            editingNoteId = null;
            renderNotes();
        }

        // Cambiar prioridad
        function togglePrioritySelector(noteId, event) {
            event.stopPropagation();

            // Cerrar otros selectores
            document.querySelectorAll('.priority-selector').forEach(s => s.classList.remove('active'));

            const selector = document.getElementById(`priority-selector-${noteId}`);
            if (selector) {
                selector.classList.toggle('active');
            }
        }

        function setPriority(noteId, priority, event) {
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].priority = priority;
                saveToLocalStorage();
                renderNotes();
                addToHistory('priority', `Prioridad ${priority.toUpperCase()} para "${notes[noteIndex].text}"`);
            }

            // Cerrar selector
            const selector = document.getElementById(`priority-selector-${noteId}`);
            if (selector) {
                selector.classList.remove('active');
            }
        }

        // Cambiar estado de trabajo
        function toggleWorkStatusSelector(noteId, event) {
            event.stopPropagation();

            // Cerrar otros selectores
            document.querySelectorAll('.work-status-selector').forEach(s => s.classList.remove('active'));

            const selector = document.getElementById(`work-status-selector-${noteId}`);
            if (selector) {
                selector.classList.toggle('active');
            }
        }

        function setWorkStatus(noteId, status, event) {
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].workStatus = status;
                saveToLocalStorage();
                renderNotes();
                renderReviewMode();
                addToHistory('work-status', `Estado "${workStatusLabels[status]}" para "${notes[noteIndex].text}"`);
            }

            // Cerrar selector
            const selector = document.getElementById(`work-status-selector-${noteId}`);
            if (selector) {
                selector.classList.remove('active');
            }
        }

        // Cerrar selectores al hacer click fuera
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.priority-badge') && !e.target.closest('.priority-selector')) {
                document.querySelectorAll('.priority-selector').forEach(s => s.classList.remove('active'));
            }
            if (!e.target.closest('.work-status-badge') && !e.target.closest('.work-status-selector')) {
                document.querySelectorAll('.work-status-selector').forEach(s => s.classList.remove('active'));
            }
        });

        // Recategorizar y agrupar todas las notas
        async function recategorizeAndGroup() {
            if (notes.length === 0) {
                alert('No hay notas para recategorizar');
                return;
            }

            // Filtrar solo las que no tienen categoría o están en "Other"
            const notesToRecategorize = notes.filter(note => !note.category || note.category === 'Other');

            if (notesToRecategorize.length === 0) {
                alert('No hay notas sin categoría o en "Other" para recategorizar');
                return;
            }

            if (!confirm(`¿Recategorizar ${notesToRecategorize.length} nota${notesToRecategorize.length !== 1 ? 's' : ''} sin categoría o en "Other" con AI?\n\nEsto reorganizará estas notas por categorías y agrupará items similares con tags comunes.`)) {
                return;
            }

            console.log(`🔄 Recategorizando y agrupando ${notesToRecategorize.length} notas...`);
            addToHistory('recategorize', `Recategorizando y agrupando ${notesToRecategorize.length} notas sin categoría o en "Other"`);

            // Procesar solo las notas filtradas
            for (const note of notesToRecategorize) {
                console.log(`🔄 Recategorizando: "${note.text}"`);
                updateTerminalLine(note.id, '🔄 Recategorizando y agrupando...', false);

                // Marcar como no procesada para que se re-procese
                const noteIndex = notes.findIndex(n => n.id === note.id);
                if (noteIndex !== -1) {
                    notes[noteIndex].aiProcessed = false;
                }

                await processWithAI(note);

                // Pequeña pausa para no saturar el API
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            console.log('✅ Recategorización y agrupación completa');
            addToHistory('recategorize', `Recategorización y agrupación completada - items similares ahora tienen tags comunes`);
            alert('✅ Recategorización completa!\n\nLas notas sin categoría o en "Other" han sido reorganizadas por categorías y las similares han sido agrupadas con tags comunes.');
        }

        // Borrar todas las notas
        function clearAllNotes() {
            if (notes.length === 0) {
                alert('No hay notas para borrar');
                return;
            }

            if (confirm(`¿Borrar TODAS las ${notes.length} notas?`)) {
                addToHistory('clear', `Borradas ${notes.length} notas`);
                notes = [];

                const output = document.getElementById('terminalOutput');
                output.innerHTML = `
                    <div style="color: #00ff88; margin-bottom: 20px; font-size: 1.1rem;">
                        💬 Escribe tus notas y presiona Enter. La AI las organizará automáticamente.
                    </div>
                `;

                saveToLocalStorage();
                renderNotes();
                document.getElementById('terminalInput').focus();
            }
        }

        // Toggle modo asignación
        function toggleAssignmentMode() {
            assignmentMode = !assignmentMode;
            const btn = document.getElementById('assignmentModeBtn');
            const filterBar = document.getElementById('assignmentFilterBar');

            if (assignmentMode) {
                btn.classList.add('active');
                if (filterBar) filterBar.style.display = 'block';
                // Renderizar los filtros de personas
                renderAssignmentFilters();
                // Al entrar en modo asignación, NO limpiar las colapsadas
                // Las tareas ya asignadas se muestran con icono de editar
            } else {
                btn.classList.remove('active');
                if (filterBar) filterBar.style.display = 'none';
                // Al salir del modo, limpiar las colapsadas y editingAssignments
                collapsedAssignments.clear();
                editingAssignments.clear();
            }

            // Re-renderizar todas las líneas del terminal
            // En modo asignación, ordenar para mostrar sin asignar primero y filtrar aceptados
            let notesToRender = notes;

            if (assignmentMode) {
                // Filtrar aceptados si el checkbox está marcado
                if (assignmentHideAccepted) {
                    notesToRender = notesToRender.filter(note => note.reviewStatus !== 'accepted');
                }

                // Ordenar: sin personas asignadas primero
                notesToRender = [...notesToRender].sort((a, b) => {
                    const aHasPeople = a.assignedTo && a.assignedTo.length > 0;
                    const bHasPeople = b.assignedTo && b.assignedTo.length > 0;
                    if (!aHasPeople && bHasPeople) return -1;
                    if (aHasPeople && !bHasPeople) return 1;
                    return 0;
                });
            }

            // Re-ordenar elementos en el DOM y ocultar los que no están en la lista filtrada
            const terminalOutput = document.getElementById('terminalOutput');
            const notesToRenderIds = new Set(notesToRender.map(n => n.id));

            // Primero ocultar todas las líneas que no están en la lista filtrada
            notes.forEach(note => {
                const lineElement = document.getElementById(`line-${note.id}`);
                if (lineElement) {
                    if (!notesToRenderIds.has(note.id)) {
                        lineElement.style.display = 'none';
                    } else {
                        lineElement.style.display = 'block';
                    }
                }
            });

            // Luego re-ordenar y renderizar las visibles
            notesToRender.forEach(note => {
                const lineElement = document.getElementById(`line-${note.id}`);
                if (lineElement) {
                    // Mover al final para mantener orden
                    terminalOutput.appendChild(lineElement);
                    renderTerminalLine(lineElement, note.id, note.text);
                    // Restaurar estado de AI si ya fue procesado
                    if (note.aiProcessed) {
                        updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                    }
                }
            });

            renderNotes();
        }

        // Toggle ocultar aceptados en modo asignación
        function toggleAssignmentHideAccepted() {
            const checkbox = document.getElementById('assignmentHideAcceptedCheckbox');
            assignmentHideAccepted = checkbox.checked;

            // Re-renderizar filtros para mantener el estado del checkbox sincronizado
            renderAssignmentFilters();

            // Re-renderizar notas con el filtro actualizado
            renderNotes();

            // Solo re-renderizar terminal si estamos en modo asignación
            if (assignmentMode) {
                // Re-renderizar todas las líneas del terminal con el filtro actualizado
                let notesToRender = notes;

                // Filtrar aceptados si el checkbox está marcado
                if (assignmentHideAccepted) {
                    notesToRender = notesToRender.filter(note => note.reviewStatus !== 'accepted');
                }

                // Ordenar: sin personas asignadas primero
                notesToRender = [...notesToRender].sort((a, b) => {
                    const aHasPeople = a.assignedTo && a.assignedTo.length > 0;
                    const bHasPeople = b.assignedTo && b.assignedTo.length > 0;
                    if (!aHasPeople && bHasPeople) return -1;
                    if (aHasPeople && !bHasPeople) return 1;
                    return 0;
                });

                // Re-ordenar elementos en el DOM y ocultar los que no están en la lista filtrada
                const terminalOutput = document.getElementById('terminalOutput');
                const notesToRenderIds = new Set(notesToRender.map(n => n.id));

                // Primero ocultar todas las líneas que no están en la lista filtrada
                notes.forEach(note => {
                    const lineElement = document.getElementById(`line-${note.id}`);
                    if (lineElement) {
                        if (!notesToRenderIds.has(note.id)) {
                            lineElement.style.display = 'none';
                        } else {
                            lineElement.style.display = 'block';
                        }
                    }
                });

                // Luego re-ordenar las visibles
                notesToRender.forEach(note => {
                    const lineElement = document.getElementById(`line-${note.id}`);
                    if (lineElement) {
                        terminalOutput.appendChild(lineElement);
                    }
                });
            }
        }

        // Toggle selección de persona
        function togglePerson(noteId, person, event) {
            event.stopPropagation();
            const checkbox = event.target.closest('.person-checkbox').querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;

            const label = event.target.closest('.person-checkbox');
            if (checkbox.checked) {
                label.classList.add('selected');
            } else {
                label.classList.remove('selected');
            }
        }

        // Seleccionar dificultad
        function selectDifficulty(noteId, difficulty, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS
            const escapedId = CSS.escape(String(noteId));

            // Desmarcar todos los radio buttons de dificultad
            const allRadios = document.querySelectorAll(`input[name="difficulty-${escapedId}"]`);
            allRadios.forEach(radio => {
                radio.checked = false;
                radio.closest('.person-checkbox').classList.remove('selected');
            });

            // Marcar el seleccionado
            const radio = event.target.closest('.person-checkbox').querySelector('input[type="radio"]');
            radio.checked = true;
            event.target.closest('.person-checkbox').classList.add('selected');
        }

        // Seleccionar prioridad
        function selectPriority(noteId, priority, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS
            const escapedId = CSS.escape(String(noteId));

            // Desmarcar todos los radio buttons de prioridad
            const allRadios = document.querySelectorAll(`input[name="priority-${escapedId}"]`);
            allRadios.forEach(radio => {
                radio.checked = false;
                radio.closest('.person-checkbox').classList.remove('selected');
            });

            // Marcar el seleccionado
            const radio = event.target.closest('.person-checkbox').querySelector('input[type="radio"]');
            radio.checked = true;
            event.target.closest('.person-checkbox').classList.add('selected');
        }

        // Obtener color de prioridad
        function getPriorityColor(priority) {
            const colors = {
                'low': '#00aaff',
                'medium': '#ffcc00',
                'high': '#ff6600',
                'critical': '#ff0040'
            };
            return colors[priority] || '#2e1a3a';
        }

        // Asignar personas a nota
        function assignPeople(noteId, event) {
            event.stopPropagation();

            // Escapar el noteId para selectores CSS (maneja puntos y caracteres especiales)
            const escapedId = CSS.escape(String(noteId));

            // Obtener personas seleccionadas
            const checkboxes = document.querySelectorAll(`#assignment-terminal-${escapedId} input[type="checkbox"]:checked`);
            const selectedPeople = Array.from(checkboxes).map(cb => cb.value);

            // Obtener dificultad seleccionada
            const difficultyRadio = document.querySelector(`input[name="difficulty-${escapedId}"]:checked`);
            const selectedDifficulty = difficultyRadio ? difficultyRadio.value : null;

            // Obtener prioridad seleccionada
            const priorityRadio = document.querySelector(`input[name="priority-${escapedId}"]:checked`);
            const selectedPriority = priorityRadio ? priorityRadio.value : null;

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].assignedTo = selectedPeople;
                notes[noteIndex].difficulty = selectedDifficulty;
                notes[noteIndex].priority = selectedPriority;

                saveToLocalStorage();

                // Log en historial
                const details = [];
                if (selectedPeople.length > 0) details.push(`👥 ${selectedPeople.join(', ')}`);
                if (selectedDifficulty) details.push(`📊 ${selectedDifficulty.toUpperCase()}`);
                if (selectedPriority) details.push(`⚡ ${selectedPriority.toUpperCase()}`);

                const detailsStr = details.length > 0 ? details.join(' | ') : 'sin asignaciones';
                addToHistory('assign', `Asignada "${notes[noteIndex].text}" → ${detailsStr}`);

                // Marcar esta nota como colapsada (cerrada) pero NO salir del modo de asignación
                collapsedAssignments.add(noteId);
                // Remover del modo de edición
                editingAssignments.delete(noteId);

                // Re-renderizar SOLO esta línea del terminal
                const lineElement = document.getElementById(`line-${noteId}`);
                if (lineElement) {
                    renderTerminalLine(lineElement, noteId, notes[noteIndex].text);
                    // Restaurar estado de AI si ya fue procesado
                    if (notes[noteIndex].aiProcessed) {
                        updateTerminalLine(noteId, null, false, notes[noteIndex].category, notes[noteIndex].tags || []);
                    }
                }

                renderNotes();
            }
        }

        // Habilitar edición de asignación para una tarea ya asignada
        function enableAssignmentEdit(noteId, event) {
            event.stopPropagation();

            // Remover de las colapsadas para mostrar la UI de asignación
            collapsedAssignments.delete(noteId);

            // Agregar a editingAssignments para forzar mostrar la UI de asignación
            editingAssignments.add(noteId);

            // Re-renderizar la línea del terminal para mostrar las opciones de asignación
            const note = notes.find(n => n.id === noteId);
            if (note) {
                const lineElement = document.getElementById(`line-${noteId}`);
                if (lineElement) {
                    renderTerminalLine(lineElement, noteId, note.text);
                    // Restaurar estado de AI si ya fue procesado
                    if (note.aiProcessed) {
                        updateTerminalLine(noteId, null, false, note.category, note.tags || []);
                    }
                }
            }
        }

        // Funciones para asignación en tarjetas (note cards)
        function togglePersonInCard(noteId, person, event) {
            event.preventDefault();
            event.stopPropagation();

            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                if (!notes[noteIndex].assignedTo) notes[noteIndex].assignedTo = [];
                const index = notes[noteIndex].assignedTo.indexOf(person);

                // Actualizar estado interno
                if (index > -1) {
                    notes[noteIndex].assignedTo.splice(index, 1);
                } else {
                    notes[noteIndex].assignedTo.push(person);
                }

                // Actualizar visualmente el checkbox sin re-renderizar todo
                const label = event.target.closest('label');
                const checkbox = label.querySelector('input[type="checkbox"]');
                checkbox.checked = notes[noteIndex].assignedTo.includes(person);

                // Actualizar clase CSS
                if (checkbox.checked) {
                    label.classList.add('selected');
                } else {
                    label.classList.remove('selected');
                }
            }
        }

        function selectDifficultyInCard(noteId, difficulty, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].difficulty = difficulty;
                // NO re-renderizar, dejar que el radio se maneje nativamente
            }
        }

        function selectPriorityInCard(noteId, priority, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                notes[noteIndex].priority = priority;
                // NO re-renderizar, dejar que el radio se maneje nativamente
            }
        }

        function saveAssignmentInCard(noteId, event) {
            event.stopPropagation();
            const noteIndex = notes.findIndex(n => n.id === noteId);
            if (noteIndex !== -1) {
                // Guardar a base de datos
                saveToLocalStorage();

                // Log en historial
                const details = [];
                if (notes[noteIndex].assignedTo && notes[noteIndex].assignedTo.length > 0) {
                    details.push(`👥 ${notes[noteIndex].assignedTo.join(', ')}`);
                }
                if (notes[noteIndex].difficulty) details.push(`📊 ${notes[noteIndex].difficulty.toUpperCase()}`);
                if (notes[noteIndex].priority) details.push(`⚡ ${notes[noteIndex].priority.toUpperCase()}`);

                const detailsStr = details.length > 0 ? details.join(' | ') : 'sin asignaciones';
                addToHistory('assign', `Asignada "${notes[noteIndex].text}" → ${detailsStr}`);

                // Remover del modo de edición
                editingAssignments.delete(noteId);

                renderNotes();
            }
        }

        function editAssignmentInCard(noteId, event) {
            event.stopPropagation();
            // Agregar a editingAssignments para mostrar la UI de asignación
            editingAssignments.add(noteId);
            renderNotes();
        }

        // Renderizar notas organizadas
        function renderNotes() {
            // Delegar según el modo de vista
            if (assignmentViewMode === 'person') {
                renderNotesByPerson();
                return;
            }

            // Vista por categoría (código original)
            const container = document.getElementById('notesList');
            const countEl = document.getElementById('notesCount');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas aún.<br>Empieza a escribir!</div>';
                countEl.textContent = '0 notas';
                return;
            }

            // Aplicar filtros de asignación
            let filteredNotes = notes;

            // Filtrar por persona si está en modo asignación
            if (assignmentMode && assignmentFilterPerson !== null) {
                filteredNotes = filteredNotes.filter(note =>
                    note.assignedTo && note.assignedTo.includes(assignmentFilterPerson)
                );
            }

            // Filtrar por texto
            if (assignmentMode && assignmentFilterText) {
                filteredNotes = filteredNotes.filter(note =>
                    note.text.toLowerCase().includes(assignmentFilterText) ||
                    (note.category && note.category.toLowerCase().includes(assignmentFilterText)) ||
                    (note.tags && note.tags.some(tag => tag.toLowerCase().includes(assignmentFilterText)))
                );
            }

            // Filtrar por ocultar aceptados
            if (assignmentMode && assignmentHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas que coincidan con los filtros.</div>';
                countEl.textContent = '0 notas';
                return;
            }

            countEl.textContent = `${filteredNotes.length} nota${filteredNotes.length !== 1 ? 's' : ''}`;

            // En modo asignación, separar en dos grupos: sin asignar y con asignados
            let unassignedNotes = [];
            let assignedNotes = [];

            if (assignmentMode) {
                unassignedNotes = filteredNotes.filter(note => !note.assignedTo || note.assignedTo.length === 0);
                assignedNotes = filteredNotes.filter(note => note.assignedTo && note.assignedTo.length > 0);
            }

            // Agrupar por categoría y tags
            const grouped = {};
            const notesToGroup = assignmentMode ? assignedNotes : filteredNotes;

            notesToGroup.forEach(note => {
                const category = note.category || 'Other';
                if (!grouped[category]) grouped[category] = {};

                if (note.tags && note.tags.length > 0) {
                    note.tags.forEach(tag => {
                        if (!grouped[category][tag]) grouped[category][tag] = [];
                        grouped[category][tag].push(note);
                    });
                } else {
                    if (!grouped[category]['General']) grouped[category]['General'] = [];
                    grouped[category]['General'].push(note);
                }
            });

            // Agrupar notas sin asignar (en modo asignación)
            const unassignedGrouped = {};
            if (assignmentMode && unassignedNotes.length > 0) {
                unassignedNotes.forEach(note => {
                    const category = note.category || 'Other';
                    if (!unassignedGrouped[category]) unassignedGrouped[category] = {};

                    if (note.tags && note.tags.length > 0) {
                        note.tags.forEach(tag => {
                            if (!unassignedGrouped[category][tag]) unassignedGrouped[category][tag] = [];
                            unassignedGrouped[category][tag].push(note);
                        });
                    } else {
                        if (!unassignedGrouped[category]['General']) unassignedGrouped[category]['General'] = [];
                        unassignedGrouped[category]['General'].push(note);
                    }
                });
            }

            // Renderizar
            let html = '';

            // Primero: notas sin asignar (en modo asignación)
            if (assignmentMode && Object.keys(unassignedGrouped).length > 0) {
                html += `<div style="background: rgba(255, 200, 0, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 30px; border: 2px solid rgba(255, 200, 0, 0.3);">
                    <div style="color: #ffc800; font-weight: bold; font-size: 1.2rem; margin-bottom: 20px;">
                        ⚠️ SIN ASIGNAR (${unassignedNotes.length})
                    </div>`;
                html += Object.entries(unassignedGrouped)
                    .map(([category, tagGroups]) => {
                        const totalInCategory = Object.values(tagGroups).flat().length;
                        return `
                            <div style="margin-bottom: 20px;">
                                <div style="color: #00ff88; font-weight: bold; font-size: 1rem; margin-bottom: 10px;">
                                    ${getCategoryEmoji(category)} ${category}
                                    <span style="color: #888; font-size: 0.85rem; margin-left: 10px;">(${totalInCategory})</span>
                                </div>
                                ${Object.entries(tagGroups).map(([tag, tagNotes]) => `
                                    <div class="tag-group">
                                        <div class="tag-group-header">
                                            <span>${tag}</span>
                                            <span class="tag-badge">${tagNotes.length}</span>
                                        </div>
                                        ${tagNotes.map(note => renderNoteCard(note)).join('')}
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    })
                    .join('');
                html += '</div>';
            }

            // Segundo: notas asignadas (o todas si no estamos en modo asignación)
            html += Object.entries(grouped)
                .map(([category, tagGroups]) => {
                    const totalInCategory = Object.values(tagGroups).flat().length;
                    return `
                        <div style="margin-bottom: 30px;">
                            <div style="color: #00ff88; font-weight: bold; font-size: 1.1rem; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #16213e;">
                                ${getCategoryEmoji(category)} ${category}
                                <span style="color: #888; font-size: 0.85rem; margin-left: 10px;">(${totalInCategory})</span>
                            </div>
                            ${Object.entries(tagGroups).map(([tag, tagNotes]) => `
                                <div class="tag-group">
                                    <div class="tag-group-header">
                                        <span>${tag}</span>
                                        <span class="tag-badge">${tagNotes.length}</span>
                                    </div>
                                    ${tagNotes.map(note => renderNoteCard(note)).join('')}
                                </div>
                            `).join('')}
                        </div>
                    `;
                })
                .join('');

            container.innerHTML = html;
        }

        // Renderizar notas agrupadas por persona
        function renderNotesByPerson() {
            const container = document.getElementById('notesList');
            const countEl = document.getElementById('notesCount');

            if (notes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas aún.<br>Empieza a escribir!</div>';
                countEl.textContent = '0 notas';
                return;
            }

            // Aplicar filtros de asignación
            let filteredNotes = notes;

            // Filtrar por persona si está en modo asignación
            if (assignmentMode && assignmentFilterPerson !== null) {
                filteredNotes = filteredNotes.filter(note =>
                    note.assignedTo && note.assignedTo.includes(assignmentFilterPerson)
                );
            }

            // Filtrar por texto
            if (assignmentMode && assignmentFilterText) {
                filteredNotes = filteredNotes.filter(note =>
                    note.text.toLowerCase().includes(assignmentFilterText) ||
                    (note.category && note.category.toLowerCase().includes(assignmentFilterText)) ||
                    (note.tags && note.tags.some(tag => tag.toLowerCase().includes(assignmentFilterText)))
                );
            }

            // Filtrar por ocultar aceptados
            if (assignmentMode && assignmentHideAccepted) {
                filteredNotes = filteredNotes.filter(note => note.reviewStatus !== 'accepted');
            }

            if (filteredNotes.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay notas que coincidan con los filtros.</div>';
                countEl.textContent = '0 notas';
                return;
            }

            countEl.textContent = `${filteredNotes.length} nota${filteredNotes.length !== 1 ? 's' : ''}`;

            // Agrupar notas por persona
            const groupedByPerson = {};
            const unassigned = [];

            filteredNotes.forEach(note => {
                if (note.assignedTo && note.assignedTo.length > 0) {
                    note.assignedTo.forEach(person => {
                        if (!groupedByPerson[person]) {
                            groupedByPerson[person] = [];
                        }
                        groupedByPerson[person].push(note);
                    });
                } else {
                    unassigned.push(note);
                }
            });

            // Renderizar notas por persona
            let html = '';

            // En modo asignación, mostrar notas sin asignar primero
            if (assignmentMode && unassigned.length > 0) {
                html += `
                    <div class="person-group">
                        <div class="person-group-header" style="color: #888; border-color: #444;">
                            <span>❓ Sin Asignar</span>
                            <span style="font-size: 0.9rem;">(${unassigned.length})</span>
                        </div>
                        ${unassigned.map(note => renderNoteCard(note)).join('')}
                    </div>
                `;
            }

            // Notas asignadas por persona
            people.forEach(person => {
                if (groupedByPerson[person] && groupedByPerson[person].length > 0) {
                    const personNotes = groupedByPerson[person];
                    const personColor = personColors[person] || '#00ff88';

                    html += `
                        <div class="person-group">
                            <div class="person-group-header" style="color: ${personColor} !important; border-color: ${personColor} !important; background: rgba(${hexToRgb(personColor)}, 0.1);">
                                <span style="color: ${personColor} !important; font-weight: bold;">👤 ${person}</span>
                                <span style="font-size: 0.9rem; color: #888;">(${personNotes.length})</span>
                            </div>
                            ${personNotes.map(note => renderNoteCard(note)).join('')}
                        </div>
                    `;
                }
            });

            // Notas sin asignar al final (si NO estamos en modo asignación)
            if (!assignmentMode && unassigned.length > 0) {
                html += `
                    <div class="person-group">
                        <div class="person-group-header" style="color: #888; border-color: #444;">
                            <span>❓ Sin Asignar</span>
                            <span style="font-size: 0.9rem;">(${unassigned.length})</span>
                        </div>
                        ${unassigned.map(note => renderNoteCard(note)).join('')}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Renderizar una tarjeta de nota individual (reutilizable)
        function renderNoteCard(note) {
            const hasAssignment = note.assignedTo && note.assignedTo.length > 0;
            const showAssignmentUI = assignmentMode && (!hasAssignment || editingAssignments.has(note.id));

            return `
                <div class="note-card ${note.priority ? 'priority-' + note.priority : ''}" style="position: relative;">
                    ${editingNoteId === note.id ? `
                        <input type="text"
                               class="note-edit-input"
                               id="edit-input-${note.id}"
                               value="${escapeHtml(note.text)}"
                               onkeypress="if(event.key==='Enter') saveEditNote(${note.id}, event); else if(event.key==='Escape') cancelEditNote(event);"
                               autofocus>
                        <div class="edit-actions">
                            <button class="save-btn" onclick="saveEditNote(${note.id}, event)">✓ Guardar</button>
                            <button class="cancel-btn" onclick="cancelEditNote(event)">✕ Cancelar</button>
                        </div>
                    ` : `
                        <div class="note-card-content">
                            <div class="note-card-text" onclick="startEditNote(${note.id}, event)" style="cursor: pointer;">${escapeHtml(note.text)}</div>
                            <div class="note-card-badges">
                                <span class="note-category-badge">${getCategoryEmoji(note.category)} ${note.category}</span>
                                ${note.tags && note.tags.length > 0 ? `
                                    <div class="note-tags-container">
                                        ${note.tags.map(tag => `<span class="note-tag">${tag}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${showAssignmentUI ? `
                            <div class="assignment-section" style="margin-top: 12px; padding: 12px; background: #16213e; border-radius: 6px;">
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">👥 ASIGNAR A:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${people.map(person => `
                                            <label class="person-checkbox ${note.assignedTo && note.assignedTo.includes(person) ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="togglePersonInCard(${note.id}, '${person}', event)">
                                                <input type="checkbox"
                                                       value="${person}"
                                                       ${note.assignedTo && note.assignedTo.includes(person) ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${person}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">📊 DIFICULTAD:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${difficulties.map(diff => `
                                            <label class="person-checkbox ${note.difficulty === diff.toLowerCase() ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="selectDifficultyInCard(${note.id}, '${diff.toLowerCase()}', event)">
                                                <input type="radio"
                                                       name="difficulty-card-${note.id}"
                                                       value="${diff.toLowerCase()}"
                                                       ${note.difficulty === diff.toLowerCase() ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${diff}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <div style="color: #888; font-size: 0.75rem; margin-bottom: 6px; font-weight: bold;">⚡ PRIORIDAD:</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${priorities.map(prio => `
                                            <label class="person-checkbox ${note.priority === prio.toLowerCase() ? 'selected' : ''}"
                                                   style="padding: 6px 12px; cursor: pointer;"
                                                   onclick="selectPriorityInCard(${note.id}, '${prio.toLowerCase()}', event)">
                                                <input type="radio"
                                                       name="priority-card-${note.id}"
                                                       value="${prio.toLowerCase()}"
                                                       ${note.priority === prio.toLowerCase() ? 'checked' : ''}
                                                       style="margin-right: 4px;">
                                                ${prio}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <button class="save-btn" onclick="saveAssignmentInCard(${note.id}, event)" style="width: 100%;">✓ Guardar Asignación</button>
                            </div>
                        ` : note.assignedTo && note.assignedTo.length > 0 ? `
                            <div class="assigned-people-container" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                ${note.assignedTo.map(person => `<span class="assigned-person" style="${getPersonColorStyle(person)}">👤 ${person}</span>`).join('')}
                                ${assignmentMode ? `<button class="edit-btn" onclick="editAssignmentInCard(${note.id}, event)" style="padding: 4px 8px; font-size: 0.8rem;">✎ Editar</button>` : ''}
                            </div>
                        ` : ''}
                        <div class="note-card-meta">
                            <span>${formatTime(note.timestamp)}</span>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span class="work-status-badge"
                                      onclick="toggleWorkStatusSelector(${note.id}, event)"
                                      style="background: ${workStatusColors[note.workStatus || 'not_started']};">
                                    ${workStatusLabels[note.workStatus || 'not_started']}
                                </span>
                                <span class="priority-badge ${note.priority ? 'priority-' + note.priority : ''}"
                                      onclick="togglePrioritySelector(${note.id}, event)"
                                      style="${!note.priority ? 'background: #16213e; color: #888;' : ''}">
                                    ${note.priority ? note.priority.toUpperCase() : '⚡ Prioridad'}
                                </span>
                                <button class="edit-btn" onclick="startEditNote(${note.id}, event)">✎</button>
                                <button class="delete-btn" onclick="deleteNote(${note.id}, event)">✕</button>
                            </div>
                        </div>
                        <div class="work-status-selector" id="work-status-selector-${note.id}">
                            <button class="work-status-option" style="background: ${workStatusColors.not_started};" onclick="setWorkStatus(${note.id}, 'not_started', event)">⭕ NO EMPEZADO</button>
                            <button class="work-status-option" style="background: ${workStatusColors.wip};" onclick="setWorkStatus(${note.id}, 'wip', event)">🔄 WIP</button>
                            <button class="work-status-option" style="background: ${workStatusColors.awaiting_review};" onclick="setWorkStatus(${note.id}, 'awaiting_review', event)">⏳ ESPERANDO REVISIÓN</button>
                            <button class="work-status-option" style="background: ${workStatusColors.accepted};" onclick="setWorkStatus(${note.id}, 'accepted', event)">✅ ACEPTADO</button>
                            <button class="work-status-option" style="background: ${workStatusColors.rejected};" onclick="setWorkStatus(${note.id}, 'rejected', event)">❌ RECHAZADO</button>
                        </div>
                        <div class="priority-selector" id="priority-selector-${note.id}">
                            <button class="priority-option priority-critical" onclick="setPriority(${note.id}, 'critical', event)">🔴 CRÍTICA</button>
                            <button class="priority-option priority-high" onclick="setPriority(${note.id}, 'high', event)">🟠 ALTA</button>
                            <button class="priority-option priority-medium" onclick="setPriority(${note.id}, 'medium', event)">🟡 MEDIA</button>
                            <button class="priority-option priority-low" onclick="setPriority(${note.id}, 'low', event)">🔵 BAJA</button>
                        </div>
                    `}
                </div>
            `;
        }

        // Agregar al historial
        function addToHistory(action, description) {
            history.unshift({
                timestamp: new Date().toISOString(),
                action: action,
                description: description
            });

            if (history.length > 100) {
                history = history.slice(0, 100);
            }

            saveToLocalStorage();
            renderHistory();
        }

        // Renderizar historial
        function renderHistory() {
            const container = document.getElementById('historyContent');

            if (history.length === 0) {
                container.innerHTML = '<div class="empty-state">No hay historial aún</div>';
                return;
            }

            container.innerHTML = history.map(item => `
                <div class="history-item">
                    <span class="time">${formatTime(item.timestamp)}</span>
                    <span class="action">${escapeHtml(item.description)}</span>
                </div>
            `).join('');
        }

        // Toggle historial
        function toggleHistory() {
            document.getElementById('historyPanel').classList.toggle('active');
        }

        // Toggle entre vista por categoría y por persona
        function toggleView(mode) {
            assignmentViewMode = mode;

            // Actualizar botones
            const categoryBtn = document.getElementById('viewByCategoryBtn');
            const personBtn = document.getElementById('viewByPersonBtn');

            if (mode === 'category') {
                categoryBtn.style.background = '#00ff88';
                categoryBtn.style.color = '#0a0a0f';
                categoryBtn.style.fontWeight = 'bold';
                personBtn.style.background = 'transparent';
                personBtn.style.color = '#888';
                personBtn.style.fontWeight = 'normal';
            } else {
                personBtn.style.background = '#00ff88';
                personBtn.style.color = '#0a0a0f';
                personBtn.style.fontWeight = 'bold';
                categoryBtn.style.background = 'transparent';
                categoryBtn.style.color = '#888';
                categoryBtn.style.fontWeight = 'normal';
            }

            renderNotes();
        }

        // Exportar notas
        function exportNotes() {
            if (notes.length === 0) {
                alert('No hay notas para exportar');
                return;
            }

            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                notes: notes,
                history: history
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const date = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `eggscape-notes-${date}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addToHistory('export', `Exportadas ${notes.length} notas`);
            console.log('✅ Notas exportadas');
        }

        // Exportar notas por persona
        function exportByPerson() {
            if (notes.length === 0) {
                alert('No hay notas para exportar');
                return;
            }

            // Agrupar notas por persona
            const tasksByPerson = {};
            const unassignedTasks = [];

            notes.forEach(note => {
                if (note.assignedTo && note.assignedTo.length > 0) {
                    note.assignedTo.forEach(person => {
                        if (!tasksByPerson[person]) {
                            tasksByPerson[person] = [];
                        }
                        tasksByPerson[person].push(note);
                    });
                } else {
                    unassignedTasks.push(note);
                }
            });

            // Generar reporte en texto
            const date = new Date().toLocaleDateString('es-AR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            let report = `╔════════════════════════════════════════════════════════════════╗\n`;
            report += `║     EGGSCAPE - TAREAS POR PERSONA - ${date}     ║\n`;
            report += `╚════════════════════════════════════════════════════════════════╝\n\n`;

            // Ordenar personas alfabéticamente
            const sortedPeople = Object.keys(tasksByPerson).sort();

            sortedPeople.forEach(person => {
                const tasks = tasksByPerson[person];
                report += `\n${'═'.repeat(70)}\n`;
                report += `👤 ${person} - ${tasks.length} tarea${tasks.length !== 1 ? 's' : ''}\n`;
                report += `${'═'.repeat(70)}\n\n`;

                // Agrupar por prioridad
                const byPriority = {
                    'critical': [],
                    'high': [],
                    'medium': [],
                    'low': [],
                    'none': []
                };

                tasks.forEach(task => {
                    const priority = task.priority || 'none';
                    byPriority[priority].push(task);
                });

                // Mostrar por prioridad
                const priorityOrder = ['critical', 'high', 'medium', 'low', 'none'];
                const priorityLabels = {
                    'critical': '🔴 CRÍTICA',
                    'high': '🟠 ALTA',
                    'medium': '🟡 MEDIA',
                    'low': '🔵 BAJA',
                    'none': '⚪ SIN PRIORIDAD'
                };

                priorityOrder.forEach(priority => {
                    const priorityTasks = byPriority[priority];
                    if (priorityTasks.length > 0) {
                        report += `  ${priorityLabels[priority]}:\n`;
                        report += `  ${'-'.repeat(65)}\n`;

                        priorityTasks.forEach((task, index) => {
                            report += `  ${index + 1}. ${task.text}\n`;

                            // Información adicional
                            const details = [];
                            if (task.category) details.push(`Categoría: ${task.category}`);
                            if (task.difficulty) details.push(`Dificultad: ${task.difficulty.toUpperCase()}`);
                            if (task.tags && task.tags.length > 0) details.push(`Tags: ${task.tags.join(', ')}`);

                            if (details.length > 0) {
                                report += `     ${details.join(' | ')}\n`;
                            }
                            report += `\n`;
                        });
                    }
                });
            });

            // Tareas sin asignar
            if (unassignedTasks.length > 0) {
                report += `\n${'═'.repeat(70)}\n`;
                report += `📋 TAREAS SIN ASIGNAR - ${unassignedTasks.length} tarea${unassignedTasks.length !== 1 ? 's' : ''}\n`;
                report += `${'═'.repeat(70)}\n\n`;

                unassignedTasks.forEach((task, index) => {
                    report += `${index + 1}. ${task.text}\n`;

                    const details = [];
                    if (task.category) details.push(`Categoría: ${task.category}`);
                    if (task.difficulty) details.push(`Dificultad: ${task.difficulty.toUpperCase()}`);
                    if (task.priority) details.push(`Prioridad: ${task.priority.toUpperCase()}`);
                    if (task.tags && task.tags.length > 0) details.push(`Tags: ${task.tags.join(', ')}`);

                    if (details.length > 0) {
                        report += `   ${details.join(' | ')}\n`;
                    }
                    report += `\n`;
                });
            }

            // Resumen
            report += `\n${'═'.repeat(70)}\n`;
            report += `📊 RESUMEN\n`;
            report += `${'═'.repeat(70)}\n`;
            report += `Total de tareas: ${notes.length}\n`;
            report += `Tareas asignadas: ${notes.filter(n => n.assignedTo && n.assignedTo.length > 0).length}\n`;
            report += `Tareas sin asignar: ${unassignedTasks.length}\n`;
            report += `Personas con tareas: ${sortedPeople.length}\n`;

            // Descargar archivo
            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const dateStr = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `eggscape-tareas-por-persona-${dateStr}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addToHistory('export', `Exportadas tareas por persona (${sortedPeople.length} personas)`);
            console.log('✅ Tareas por persona exportadas');
        }

        // Importar notas
        function importNotes(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validar estructura
                    if (!data.notes || !Array.isArray(data.notes)) {
                        throw new Error('Formato de archivo inválido');
                    }

                    const importCount = data.notes.length;

                    if (!confirm(`¿Importar ${importCount} nota${importCount !== 1 ? 's' : ''}?\n\nEsto se agregará a tus notas existentes.`)) {
                        event.target.value = '';
                        return;
                    }

                    // Agregar notas importadas
                    data.notes.forEach(note => {
                        // Asignar nuevo ID para evitar conflictos
                        note.id = Date.now() + Math.random();

                        // Asegurar que tenga todos los campos necesarios
                        if (!note.assignedTo) note.assignedTo = [];
                        if (!note.difficulty) note.difficulty = null;
                        if (!note.priority) note.priority = null;
                        if (!note.reviewStatus) note.reviewStatus = null;
                        if (!note.rejectionComment) note.rejectionComment = '';
                        if (!note.workStatus) note.workStatus = 'not_started';
                        if (!note.buildReviewDate) note.buildReviewDate = note.timestamp || new Date().toISOString();

                        notes.push(note);
                        addTerminalLine(note.text, note.id);
                        if (note.aiProcessed) {
                            updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                        }
                    });

                    // Importar historial si existe
                    if (data.history && Array.isArray(data.history)) {
                        data.history.forEach(item => history.push(item));
                    }

                    saveToLocalStorage();
                    renderNotes();
                    renderHistory();

                    addToHistory('import', `Importadas ${importCount} notas`);
                    alert(`✅ Importadas ${importCount} notas correctamente!`);
                    console.log('✅ Notas importadas');

                } catch (error) {
                    console.error('❌ Error importando:', error);
                    alert('❌ Error al importar el archivo.\n\nAsegúrate de que sea un archivo válido exportado desde esta aplicación.');
                }

                // Limpiar input
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Guardar/Cargar desde servidor
        async function saveToLocalStorage() {
            // Guardar localmente también como backup
            localStorage.setItem('eggscape_notes', JSON.stringify(notes));
            localStorage.setItem('eggscape_history', JSON.stringify(history));

            // Guardar en Supabase
            try {
                console.log('💾 [SAVE] Intentando guardar en Supabase...', notes.length, 'notas');
                console.log('💾 [SAVE] supabaseClient:', supabaseClient);
                console.log('💾 [SAVE] Datos a guardar:', { notesCount: notes.length, historyCount: history.length });

                const { data, error } = await supabaseClient
                    .from('app_data')
                    .update({
                        data: { notes, history },
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', 1);

                console.log('💾 [SAVE] Respuesta de Supabase - data:', data);
                console.log('💾 [SAVE] Respuesta de Supabase - error:', error);

                if (error) {
                    console.error('❌ [SAVE] Error guardando en Supabase:', error);
                    console.error('❌ [SAVE] Error details:', JSON.stringify(error, null, 2));
                    showNotification('⚠️ Error guardando en Supabase. Datos guardados solo localmente.', 'error');
                } else {
                    console.log('✅ [SAVE] Guardado exitoso en Supabase');
                }
            } catch (error) {
                console.error('❌ [SAVE] Error de red guardando en Supabase:', error);
                console.error('❌ [SAVE] Error stack:', error.stack);
                showNotification('⚠️ Error de conexión con Supabase. Datos guardados solo localmente.', 'error');
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'error' ? '#ff4444' : '#00ff88'};
                color: ${type === 'error' ? '#fff' : '#000'};
                padding: 15px 20px;
                border-radius: 5px;
                font-family: 'Courier New', monospace;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
        }

        async function loadFromLocalStorage() {
            try {
                // Cargar desde Supabase
                console.log('📥 [LOAD] Cargando datos desde Supabase...');
                console.log('📥 [LOAD] supabaseClient:', supabaseClient);

                const { data, error } = await supabaseClient
                    .from('app_data')
                    .select('data')
                    .eq('id', 1)
                    .single();

                console.log('📥 [LOAD] Respuesta de Supabase - data:', data);
                console.log('📥 [LOAD] Respuesta de Supabase - error:', error);

                if (error) {
                    console.error('❌ [LOAD] Error cargando desde Supabase:', error);
                    console.error('❌ [LOAD] Error details:', JSON.stringify(error, null, 2));
                    // Fallback a localStorage
                    console.log('⚠️ [LOAD] Usando localStorage como fallback');
                    const savedNotes = localStorage.getItem('eggscape_notes');
                    const savedHistory = localStorage.getItem('eggscape_history');
                    console.log('⚠️ [LOAD] localStorage notes:', savedNotes ? 'encontradas' : 'no encontradas');
                    console.log('⚠️ [LOAD] localStorage history:', savedHistory ? 'encontrado' : 'no encontrado');
                    if (savedNotes) notes = JSON.parse(savedNotes);
                    if (savedHistory) history = JSON.parse(savedHistory);
                } else {
                    console.log('📥 [LOAD] data.data:', data.data);
                    notes = data.data.notes || [];
                    history = data.data.history || [];
                    console.log('✅ [LOAD] Notas cargadas desde Supabase:', notes.length);
                }
            } catch (error) {
                // Fallback a localStorage
                console.error('⚠️ [LOAD] Exception cargando desde Supabase, usando localStorage:', error);
                console.error('⚠️ [LOAD] Error stack:', error.stack);
                const savedNotes = localStorage.getItem('eggscape_notes');
                const savedHistory = localStorage.getItem('eggscape_history');
                if (savedNotes) notes = JSON.parse(savedNotes);
                if (savedHistory) history = JSON.parse(savedHistory);
            }

            // Asegurar que todas las notas tengan workStatus (backward compatibility)
            notes.forEach(note => {
                if (!note.workStatus) note.workStatus = 'not_started';
                if (!note.buildReviewDate) note.buildReviewDate = note.timestamp || new Date().toISOString();
            });

            // Renderizar notas cargadas
            notes.forEach(note => {
                addTerminalLine(note.text, note.id);
                if (note.aiProcessed) {
                    updateTerminalLine(note.id, null, false, note.category, note.tags || []);
                }
            });
        }

        // Utilidades
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' });
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 255, 136';
        }

        function getPersonColorStyle(person) {
            const color = personColors[person] || '#ff88ff';
            return `background: ${color}; color: #000; border-color: ${color}; font-weight: bold;`;
        }

        function getCategoryEmoji(category) {
            const emojis = {
                'Bug': '🐛', 'Feature': '✨', 'Performance': '⚡', 'UI': '🎨',
                'Sound': '🔊', 'Gameplay': '🎮', 'Level Design': '🗺️',
                'Backend': '⚙️', 'Tools': '🔧', 'Other': '📝'
            };
            return emojis[category] || '📝';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Inicializar
        init();
    </script>
</body>
</html>
